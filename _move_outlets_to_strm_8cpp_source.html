<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.7.6.1"/>
        
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>

        <title>SEIMS-2016: preprocess/cpp_src/TauDEM/MoveOutletsToStrm.cpp Source File</title>
        
        <!--<link href="$relpath^tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="$relpath^dynsections.js"></script>
        
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

        <link href="$relpath^doxygen.css" rel="stylesheet" type="text/css" />
        $extrastylesheet

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="$relpath^doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">SEIMS-2016 1.0-beta</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">preprocess/cpp_src/TauDEM/MoveOutletsToStrm.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*  MoveOutletsToStrm function to move outlets to a stream.</span>
<a name="l00002"></a>00002 <span class="comment">     </span>
<a name="l00003"></a>00003 <span class="comment">  David Tarboton, Teklu Tesfa, Dan Watson</span>
<a name="l00004"></a>00004 <span class="comment">  Utah State University  </span>
<a name="l00005"></a>00005 <span class="comment">  May 23, 2010 </span>
<a name="l00006"></a>00006 <span class="comment">  </span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">  This function moves outlet point that are off a stream raster grid down D8 flow directions </span>
<a name="l00009"></a>00009 <span class="comment">  until a stream raster grid is encountered.  Input is a flow direction grid, stream raster grid </span>
<a name="l00010"></a>00010 <span class="comment">  and outlets shapefile.  Output is a new outlets shapefile where each point has been moved to </span>
<a name="l00011"></a>00011 <span class="comment">  coincide with the stream raster grid if possible.  A field &#39;dist_moved&#39; is added to the new </span>
<a name="l00012"></a>00012 <span class="comment">  outlets shapefile to indicate the changes made to each point.  Points that are already on the </span>
<a name="l00013"></a>00013 <span class="comment">  stream raster (src) grid are not moved and their &#39;dist_moved&#39; field is assigned a value 0.  </span>
<a name="l00014"></a>00014 <span class="comment">  Points that are initially not on the stream raster grid are moved by sliding them along D8 </span>
<a name="l00015"></a>00015 <span class="comment">  flow directions until one of the following occurs:</span>
<a name="l00016"></a>00016 <span class="comment">  a.    A stream raster grid cell is encountered before traversing the max_dist number of grid cells.  </span>
<a name="l00017"></a>00017 <span class="comment">   The point is moved and &#39;dist_moved&#39; field is assigned a value indicating how many grid cells the </span>
<a name="l00018"></a>00018 <span class="comment">   point was moved.</span>
<a name="l00019"></a>00019 <span class="comment">  b.    More thanthe max_number of grid cells are traversed, or the traversal ends up going out of </span>
<a name="l00020"></a>00020 <span class="comment">  the domain (encountering a no data D8 flow direction value).  The point is not moved and the </span>
<a name="l00021"></a>00021 <span class="comment">  &#39;dist_moved&#39; field is assigned a value of -1.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">*/</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">/*  Copyright (C) 2010  David Tarboton, Utah State University</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">This program is free software; you can redistribute it and/or</span>
<a name="l00028"></a>00028 <span class="comment">modify it under the terms of the GNU General Public License </span>
<a name="l00029"></a>00029 <span class="comment">version 2, 1991 as published by the Free Software Foundation.</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">This program is distributed in the hope that it will be useful,</span>
<a name="l00032"></a>00032 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00033"></a>00033 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00034"></a>00034 <span class="comment">GNU General Public License for more details.</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">A copy of the full GNU General Public License is included in file </span>
<a name="l00037"></a>00037 <span class="comment">gpl.html. This is also available at:</span>
<a name="l00038"></a>00038 <span class="comment">http://www.gnu.org/copyleft/gpl.html</span>
<a name="l00039"></a>00039 <span class="comment">or from:</span>
<a name="l00040"></a>00040 <span class="comment">The Free Software Foundation, Inc., 59 Temple Place - Suite 330, </span>
<a name="l00041"></a>00041 <span class="comment">Boston, MA  02111-1307, USA.</span>
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">If you wish to use or incorporate this program (or parts of it) into </span>
<a name="l00044"></a>00044 <span class="comment">other software that does not meet the GNU General Public License </span>
<a name="l00045"></a>00045 <span class="comment">conditions contact the author to request permission.</span>
<a name="l00046"></a>00046 <span class="comment">David G. Tarboton  </span>
<a name="l00047"></a>00047 <span class="comment">Utah State University </span>
<a name="l00048"></a>00048 <span class="comment">8200 Old Main Hill </span>
<a name="l00049"></a>00049 <span class="comment">Logan, UT 84322-8200 </span>
<a name="l00050"></a>00050 <span class="comment">USA </span>
<a name="l00051"></a>00051 <span class="comment">http://www.engineering.usu.edu/dtarb/ </span>
<a name="l00052"></a>00052 <span class="comment">email:  dtarb@usu.edu </span>
<a name="l00053"></a>00053 <span class="comment">*/</span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">//  This software is distributed from http://hydrology.usu.edu/taudem/</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">// 1/25/14.  Modified to use shapelib by Chris George</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;commonLib.h&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;linearpart.h&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;createpart.h&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;tiffIO.h&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;shapelib/shapefil.h&quot;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;MoveOutletsToStrm.h&quot;</span>
<a name="l00068"></a>00068 <span class="keyword">using namespace </span>std;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keywordtype">int</span> outletstosrc(<span class="keywordtype">char</span> *pfile, <span class="keywordtype">char</span> *srcfile, <span class="keywordtype">char</span> *outletshapefile, <span class="keywordtype">char</span> *movedoutletshapefile, <span class="keywordtype">int</span> maxdist)
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     MPI_Init(NULL,NULL);{
<a name="l00076"></a>00076         <span class="keywordtype">int</span> rank,size;
<a name="l00077"></a>00077         MPI_Comm_rank(MCW,&amp;rank);
<a name="l00078"></a>00078         MPI_Comm_size(MCW,&amp;size);
<a name="l00079"></a>00079         <span class="keywordflow">if</span>(rank==0)printf(<span class="stringliteral">&quot;MoveOutletsToStreams version %s\n&quot;</span>,TDVERSION);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         <span class="keywordtype">double</span> begin,end;
<a name="l00082"></a>00082         <span class="comment">//Begin timer</span>
<a name="l00083"></a>00083         begin = MPI_Wtime();
<a name="l00084"></a>00084         <span class="keywordtype">int</span> d1[9] = {-99,0,-1,-1,-1,0,1,1,1};
<a name="l00085"></a>00085         <span class="keywordtype">int</span> d2[9] = {-99,1,1,0,-1,-1,-1,0,1};
<a name="l00086"></a>00086 
<a name="l00087"></a>00087         <span class="comment">//load the stream raster grid into a linear partition</span>
<a name="l00088"></a>00088         <span class="comment">//Create tiff object, read and store header info</span>
<a name="l00089"></a>00089         <span class="comment">//  MPI_Abort(MCW,5);</span>
<a name="l00090"></a>00090         tiffIO src(srcfile, SHORT_TYPE);
<a name="l00091"></a>00091         <span class="keywordtype">long</span> srcTotalX = src.getTotalX();
<a name="l00092"></a>00092         <span class="keywordtype">long</span> srcTotalY = src.getTotalY();
<a name="l00093"></a>00093         <span class="keywordtype">double</span> srcdx = src.getdx();
<a name="l00094"></a>00094         <span class="keywordtype">double</span> srcdy = src.getdy();
<a name="l00095"></a>00095         <span class="comment">//if(rank==0)</span>
<a name="l00096"></a>00096         <span class="comment">//{</span>
<a name="l00097"></a>00097         <span class="comment">//  float timeestimate=(2e-7*srcTotalX*srcTotalY/pow((double) size,0.65))/60+1;  // Time estimate in minutes</span>
<a name="l00098"></a>00098         <span class="comment">//  fprintf(stderr,&quot;This run may take on the order of %.0f minutes to complete.\n&quot;,timeestimate);</span>
<a name="l00099"></a>00099         <span class="comment">//  fprintf(stderr,&quot;This estimate is very approximate. \nRun time is highly uncertain as it depends on the complexity of the input data \nand speed and memory of the computer. This estimate is based on our testing on \na dual quad core Dell Xeon E5405 2.0GHz PC with 16GB RAM.\n&quot;);</span>
<a name="l00100"></a>00100         <span class="comment">//  fflush(stderr);</span>
<a name="l00101"></a>00101         <span class="comment">//}</span>
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <span class="comment">//Create partition and read data</span>
<a name="l00105"></a>00105         tdpartition *srcData;
<a name="l00106"></a>00106         srcData = CreateNewPartition(src.getDatatype(), srcTotalX, srcTotalY, srcdx, srcdy, src.getNodata());
<a name="l00107"></a>00107         <span class="keywordtype">int</span> srcnx = srcData-&gt;getnx();
<a name="l00108"></a>00108         <span class="keywordtype">int</span> srcny = srcData-&gt;getny();
<a name="l00109"></a>00109         <span class="keywordtype">int</span> srcxstart, srcystart;  <span class="comment">// DGT Why are these declared as int if they are to be used as long</span>
<a name="l00110"></a>00110         srcData-&gt;localToGlobal(0, 0, srcxstart, srcystart);  <span class="comment">//  DGT here no typecast - but 2 lines down there is typecast - why</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         src.read((<span class="keywordtype">long</span>)srcxstart, (<span class="keywordtype">long</span>)srcystart, (<span class="keywordtype">long</span>)srcny, (<span class="keywordtype">long</span>)srcnx, srcData-&gt;getGridPointer());
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         <span class="comment">//load the d8 flow grid into a linear partition</span>
<a name="l00115"></a>00115         <span class="comment">//Create tiff object, read and store header info</span>
<a name="l00116"></a>00116         tiffIO p(pfile, SHORT_TYPE);
<a name="l00117"></a>00117         <span class="keywordtype">long</span> pTotalX = p.getTotalX();
<a name="l00118"></a>00118         <span class="keywordtype">long</span> pTotalY = p.getTotalY();
<a name="l00119"></a>00119         <span class="keywordtype">double</span> pdx = p.getdx();
<a name="l00120"></a>00120         <span class="keywordtype">double</span> pdy = p.getdy();
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <span class="comment">//Create partition and read data</span>
<a name="l00123"></a>00123         tdpartition *flowData;
<a name="l00124"></a>00124         flowData = CreateNewPartition(p.getDatatype(), pTotalX, pTotalY, pdx, pdy, p.getNodata());
<a name="l00125"></a>00125         <span class="keywordtype">int</span> pnx = flowData-&gt;getnx();
<a name="l00126"></a>00126         <span class="keywordtype">int</span> pny = flowData-&gt;getny();
<a name="l00127"></a>00127         <span class="keywordtype">int</span> pxstart, pystart;
<a name="l00128"></a>00128         flowData-&gt;localToGlobal(0, 0, pxstart, pystart);
<a name="l00129"></a>00129         p.read(pxstart, pystart, pny, pnx, flowData-&gt;getGridPointer());
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="keywordflow">if</span>(!p.compareTiff(src)){
<a name="l00132"></a>00132             printf(<span class="stringliteral">&quot;src and p files not the same size. Exiting \n&quot;</span>);
<a name="l00133"></a>00133             MPI_Abort(MCW,4);
<a name="l00134"></a>00134         }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         <span class="comment">//load the shapefile that contains the unmoved src points</span>
<a name="l00138"></a>00138         <span class="comment">//copy the shapefile to a new shapefile called shpmoved on p0</span>
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         <span class="comment">//  Code added to read shape file</span>
<a name="l00141"></a>00141         SHPHandle sh, shmoved;
<a name="l00142"></a>00142         DBFHandle dbf, dbfmoved;
<a name="l00143"></a>00143         <span class="keywordtype">double</span> *xnode, *ynode;
<a name="l00144"></a>00144         <span class="keywordtype">double</span> *origxnode, *origynode;
<a name="l00145"></a>00145         <span class="keywordtype">int</span> nxy;
<a name="l00146"></a>00146         <span class="keywordtype">long</span> *dist_moved;  <span class="comment">//*ismoved,  DGT decided ismoved is not needed</span>
<a name="l00147"></a>00147         <span class="keywordtype">int</span> *part_has;  <span class="comment">// variable to keep track of which partition has control of outlet</span>
<a name="l00148"></a>00148         <span class="keywordtype">int</span> nfields;
<a name="l00149"></a>00149         <span class="keywordtype">int</span> i,j;
<a name="l00150"></a>00150         <span class="keywordtype">int</span> * indexMap;
<a name="l00151"></a>00151         DBFFieldType * types;
<a name="l00152"></a>00152         <span class="keywordtype">int</span> dmIndex;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         <span class="keywordflow">if</span>(rank==0){
<a name="l00155"></a>00155             sh = SHPOpen(outletshapefile, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00156"></a>00156             <span class="keywordtype">char</span> outletsdbf[MAXLN];
<a name="l00157"></a>00157             nameadd(outletsdbf, outletshapefile, <span class="stringliteral">&quot;.dbf&quot;</span>);
<a name="l00158"></a>00158             dbf = DBFOpen(outletsdbf, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00159"></a>00159             <span class="keywordflow">if</span> ((sh != NULL) &amp;&amp; (dbf != NULL)) {
<a name="l00160"></a>00160                 <span class="comment">// Strategy is to create a new shapefile with identical properties and fields</span>
<a name="l00161"></a>00161                 shmoved = SHPCreate(movedoutletshapefile, SHPT_POINT);
<a name="l00162"></a>00162                 <span class="keywordtype">char</span> movedoutletsdbf[MAXLN];
<a name="l00163"></a>00163                 nameadd(movedoutletsdbf, movedoutletshapefile, <span class="stringliteral">&quot;.dbf&quot;</span>);
<a name="l00164"></a>00164                 dbfmoved = DBFCreate(movedoutletsdbf);
<a name="l00165"></a>00165                 nfields=DBFGetFieldCount(dbf);
<a name="l00166"></a>00166                 indexMap = <span class="keyword">new</span> <span class="keywordtype">int</span>[nfields];
<a name="l00167"></a>00167                 types = <span class="keyword">new</span> DBFFieldType[nfields];
<a name="l00168"></a>00168                 <span class="keywordtype">char</span> *fieldname = <span class="keyword">new</span> <span class="keywordtype">char</span>[12];
<a name="l00169"></a>00169                 <span class="keywordflow">for</span>(i=0; i&lt;nfields; i++) {
<a name="l00170"></a>00170                     <span class="keywordtype">int</span> * pWidth = NULL;
<a name="l00171"></a>00171                     <span class="keywordtype">int</span> width = 0;
<a name="l00172"></a>00172                     <span class="keywordtype">int</span> * pPrecision = NULL;
<a name="l00173"></a>00173                     <span class="keywordtype">int</span> precision = 0;
<a name="l00174"></a>00174                     DBFFieldType type = DBFGetFieldInfo(dbf, i, fieldname, pWidth, pPrecision);
<a name="l00175"></a>00175                     types[i] = type;
<a name="l00176"></a>00176                     <span class="keywordflow">if</span> (pWidth == NULL) {
<a name="l00177"></a>00177                         <span class="keywordflow">if</span> (type == FTInteger) width = 6;
<a name="l00178"></a>00178                         <span class="keywordflow">else</span> width = 12;
<a name="l00179"></a>00179                     } <span class="keywordflow">else</span> {
<a name="l00180"></a>00180                         width = *pWidth;
<a name="l00181"></a>00181                     }
<a name="l00182"></a>00182                     <span class="keywordflow">if</span> (pPrecision == NULL) {
<a name="l00183"></a>00183                         <span class="keywordflow">if</span> (type = FTDouble) precision = 1;
<a name="l00184"></a>00184                         <span class="keywordflow">else</span> precision = 0;
<a name="l00185"></a>00185                     } <span class="keywordflow">else</span> {
<a name="l00186"></a>00186                         precision = *pPrecision;
<a name="l00187"></a>00187                     }
<a name="l00188"></a>00188                     <span class="keywordflow">if</span> (type != FTInvalid) {
<a name="l00189"></a>00189                         <span class="keywordtype">int</span> j = DBFAddField(dbfmoved, fieldname, type, width, precision);
<a name="l00190"></a>00190                         indexMap[i] = j;
<a name="l00191"></a>00191                     } <span class="keywordflow">else</span> {
<a name="l00192"></a>00192                         indexMap[i] = -1;
<a name="l00193"></a>00193                     }
<a name="l00194"></a>00194                 }
<a name="l00195"></a>00195                 <span class="keyword">delete</span> [] fieldname;
<a name="l00196"></a>00196                 <span class="comment">//  Insert additional field to record distance moved</span>
<a name="l00197"></a>00197                 dmIndex = DBFAddField(dbfmoved, <span class="stringliteral">&quot;Dist_moved&quot;</span>, FTInteger, 6, 0);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199                 nxy = DBFGetRecordCount(dbf);
<a name="l00200"></a>00200                 <span class="comment">//int p_size;</span>
<a name="l00201"></a>00201                 <span class="comment">//  Code below commented out on assumption of one point per shape</span>
<a name="l00202"></a>00202                 <span class="comment">//int countPts = 0;</span>
<a name="l00203"></a>00203                 <span class="comment">//</span>
<a name="l00204"></a>00204                 <span class="comment">//for( int i=0; i&lt;size; i++) {</span>
<a name="l00205"></a>00205                 <span class="comment">//  shp = sh.getShape(i);</span>
<a name="l00206"></a>00206                 <span class="comment">//  countPts += shp-&gt;size();</span>
<a name="l00207"></a>00207                 <span class="comment">//} </span>
<a name="l00208"></a>00208             } <span class="keywordflow">else</span> {
<a name="l00209"></a>00209                 printf(<span class="stringliteral">&quot;\nError opening shapefile.\n\n&quot;</span>);   
<a name="l00210"></a>00210                 nxy=0;
<a name="l00211"></a>00211                 <span class="comment">//      MPI_Abort(MCW,5);</span>
<a name="l00212"></a>00212             }
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         MPI_Bcast(&amp;nxy, 1, MPI_INT, 0, MCW);
<a name="l00216"></a>00216         <span class="keywordflow">if</span>(nxy==0)
<a name="l00217"></a>00217         {  <span class="comment">// Attempt to exit gracefully on all processors</span>
<a name="l00218"></a>00218             <span class="keywordflow">if</span>(rank==0)
<a name="l00219"></a>00219                 printf(<span class="stringliteral">&quot;Unable to read any points from shapefile\n\n&quot;</span>);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221             MPI_Finalize();
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224         xnode = <span class="keyword">new</span> <span class="keywordtype">double</span>[nxy];
<a name="l00225"></a>00225         ynode = <span class="keyword">new</span> <span class="keywordtype">double</span>[nxy];
<a name="l00226"></a>00226         origxnode = <span class="keyword">new</span> <span class="keywordtype">double</span>[nxy];
<a name="l00227"></a>00227         origynode = <span class="keyword">new</span> <span class="keywordtype">double</span>[nxy];
<a name="l00228"></a>00228         <span class="comment">//  ismoved = new long[nxy];  // DGT decided not needed </span>
<a name="l00229"></a>00229         dist_moved = <span class="keyword">new</span> <span class="keywordtype">long</span>[nxy];
<a name="l00230"></a>00230         part_has = <span class="keyword">new</span> <span class="keywordtype">int</span>[nxy];  <span class="comment">// Variable to keep track of which partition currently has control over this outlet</span>
<a name="l00231"></a>00231         <span class="keywordtype">int</span> itresh=1;  <span class="comment">// Thresholding to 1 done in source</span>
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         <span class="keywordflow">if</span>(rank==0){
<a name="l00234"></a>00234             <span class="keywordflow">for</span>(i=0; i&lt;nxy; i++) {
<a name="l00235"></a>00235                 SHPObject *shp = SHPReadObject(sh, i);
<a name="l00236"></a>00236                 xnode[i] = shp-&gt;padfX[0];
<a name="l00237"></a>00237                 ynode[i] = shp-&gt;padfY[0];
<a name="l00238"></a>00238                 origxnode[i]=xnode[i];
<a name="l00239"></a>00239                 origynode[i]=ynode[i];
<a name="l00240"></a>00240                 <span class="comment">//  Initializing</span>
<a name="l00241"></a>00241                 <span class="comment">//          ismoved[i] = 0;</span>
<a name="l00242"></a>00242                 dist_moved[i] = 0;
<a name="l00243"></a>00243                 part_has[i]=-1;  <span class="comment">// initialize part_has to -1 for all points.  This will be set to rank later</span>
<a name="l00244"></a>00244                 SHPDestroyObject(shp);
<a name="l00245"></a>00245             }
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         MPI_Bcast(xnode, nxy, MPI_DOUBLE, 0, MCW);
<a name="l00249"></a>00249         MPI_Bcast(ynode, nxy, MPI_DOUBLE, 0, MCW);
<a name="l00250"></a>00250         <span class="comment">//  MPI_Bcast(ismoved, nxy, MPI_LONG, 0, MCW);</span>
<a name="l00251"></a>00251         MPI_Bcast(dist_moved, nxy, MPI_LONG, 0, MCW);
<a name="l00252"></a>00252         MPI_Bcast(part_has, nxy, MPI_INT, 0, MCW);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254         <span class="comment">// oooooooooooooooooooooo  begin processing</span>
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         <span class="keywordtype">int</span> *outletsX, *outletsY;
<a name="l00257"></a>00257         <span class="keywordtype">int</span> tx,ty;
<a name="l00258"></a>00258         <span class="keywordtype">short</span> td;
<a name="l00259"></a>00259         outletsX = <span class="keyword">new</span> <span class="keywordtype">int</span>[nxy];
<a name="l00260"></a>00260         outletsY = <span class="keyword">new</span> <span class="keywordtype">int</span>[nxy];
<a name="l00261"></a>00261         <span class="keywordtype">int</span> done = 0;
<a name="l00262"></a>00262         <span class="keywordtype">int</span> localdone = 0;
<a name="l00263"></a>00263         <span class="keywordtype">int</span> localnodes;
<a name="l00264"></a>00264         <span class="keywordtype">int</span> totalnodes;
<a name="l00265"></a>00265         <span class="keywordtype">int</span> totaldone;
<a name="l00266"></a>00266         <span class="keywordtype">short</span> dirn;
<a name="l00267"></a>00267         <span class="keywordtype">int</span> nextx,nexty;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         <span class="comment">//Convert geo coords to grid coords</span>
<a name="l00270"></a>00270         <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++)
<a name="l00271"></a>00271             p.geoToGlobalXY(xnode[i], ynode[i], outletsX[i], outletsY[i]);
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         <span class="keywordflow">while</span>(!done){
<a name="l00274"></a>00274             <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00275"></a>00275                 flowData-&gt;globalToLocal(outletsX[i], outletsY[i], tx, ty);
<a name="l00276"></a>00276                 <span class="keywordflow">if</span>(flowData-&gt;isInPartition(tx,ty))part_has[i]=rank;  <span class="comment">// grab control if in partition</span>
<a name="l00277"></a>00277                 <span class="keywordflow">else</span> part_has[i]=-1;  <span class="comment">// some other partition has control</span>
<a name="l00278"></a>00278                 <span class="keywordflow">if</span>(flowData-&gt;isInPartition(tx,ty) &amp;&amp;dist_moved[i]&gt;=0){
<a name="l00279"></a>00279                     td=srcData-&gt;getData(tx,ty,td);
<a name="l00280"></a>00280                     <span class="comment">//  td = (char) td;  //DGT Why do we have to do this CHAR.  It seems like it was declared short so should all work</span>
<a name="l00281"></a>00281                     <span class="keywordflow">if</span>(srcData-&gt;isNodata(tx,ty) || td&lt;itresh){  <span class="comment">//  If not on stream.  The rule is any value &gt;= itresh is a stream, less or no data is not stream</span>
<a name="l00282"></a>00282                         <span class="comment">//move the outlet</span>
<a name="l00283"></a>00283                         dirn = flowData-&gt;getData(tx,ty,dirn);
<a name="l00284"></a>00284                         <span class="comment">//dirn = (char) dirn;</span>
<a name="l00285"></a>00285                         <span class="comment">//  DGT added dist_moved condition below which is: </span>
<a name="l00286"></a>00286                         <span class="comment">//  More than the max_number of grid cells are traversed, or the traversal ends up going out of the </span>
<a name="l00287"></a>00287                         <span class="comment">//  domain (encountering a no data D8 flow direction value).  </span>
<a name="l00288"></a>00288                         <span class="comment">//  The point is not moved and the &#39;dist_moved&#39; field is assigned a value of -1.</span>
<a name="l00289"></a>00289                         <span class="keywordflow">if</span>(dirn&gt;=1 &amp;&amp; dirn&lt;=8 &amp;&amp; dist_moved[i] &lt; maxdist){
<a name="l00290"></a>00290                             nextx=outletsX[i]+d2[dirn];
<a name="l00291"></a>00291                             nexty=outletsY[i]+d1[dirn];
<a name="l00292"></a>00292                             <span class="keywordflow">if</span>(nextx&gt;=0 &amp;&amp; nexty&gt;=0 &amp;&amp; nextx&lt; pTotalX &amp;&amp; nexty&lt; pTotalY){  <span class="comment">// If is within global domain</span>
<a name="l00293"></a>00293                                 outletsX[i]=nextx;
<a name="l00294"></a>00294                                 outletsY[i]=nexty;
<a name="l00295"></a>00295                                 <span class="comment">//ismoved[i]=1;</span>
<a name="l00296"></a>00296                                 dist_moved[i]++;
<a name="l00297"></a>00297                                 <span class="comment">//printf(&quot;Outlet: %d, x: %d, y: %d\n&quot;,i,nextx,nexty);</span>
<a name="l00298"></a>00298                             }<span class="keywordflow">else</span>{
<a name="l00299"></a>00299                                 <span class="comment">// moved off the map</span>
<a name="l00300"></a>00300                                 dist_moved[i]=-1;
<a name="l00301"></a>00301                             }
<a name="l00302"></a>00302                         }<span class="keywordflow">else</span>{
<a name="l00303"></a>00303                             <span class="comment">//flow data not a direction</span>
<a name="l00304"></a>00304                             dist_moved[i]=-1;
<a name="l00305"></a>00305                         }
<a name="l00306"></a>00306                     } 
<a name="l00307"></a>00307                     <span class="comment">//  No else needed because if on stream do nothing</span>
<a name="l00308"></a>00308                 }
<a name="l00309"></a>00309             }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311             <span class="comment">//share data with neighbors</span>
<a name="l00312"></a>00312             <span class="comment">//this code is linear partition specific</span>
<a name="l00313"></a>00313             <span class="keywordtype">int</span> * toutletsX = <span class="keyword">new</span> <span class="keywordtype">int</span>[nxy];
<a name="l00314"></a>00314             <span class="keywordtype">int</span> * toutletsY = <span class="keyword">new</span> <span class="keywordtype">int</span>[nxy];
<a name="l00315"></a>00315             <span class="comment">//  long * tismoved = new long[nxy];</span>
<a name="l00316"></a>00316             <span class="keywordtype">long</span> * tdist_moved = <span class="keyword">new</span> <span class="keywordtype">long</span>[nxy];
<a name="l00317"></a>00317             MPI_Status status;
<a name="l00318"></a>00318             <span class="keywordtype">int</span> *ptr;
<a name="l00319"></a>00319             <span class="keywordtype">int</span> place;
<a name="l00320"></a>00320             <span class="keywordtype">int</span> *buf;
<a name="l00321"></a>00321             <span class="keywordtype">long</span> *lbuf;
<a name="l00322"></a>00322             <span class="keywordtype">int</span> bsize=nxy*<span class="keyword">sizeof</span>(int)+MPI_BSEND_OVERHEAD;  
<a name="l00323"></a>00323             <span class="keywordtype">int</span> lsize=nxy*<span class="keyword">sizeof</span>(long)+MPI_BSEND_OVERHEAD;  
<a name="l00324"></a>00324             buf = <span class="keyword">new</span> <span class="keywordtype">int</span>[bsize];
<a name="l00325"></a>00325             lbuf = <span class="keyword">new</span> <span class="keywordtype">long</span>[lsize];
<a name="l00326"></a>00326 
<a name="l00327"></a>00327             <span class="keywordtype">int</span> txn, tyn;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329             <span class="keywordtype">int</span> dest = rank-1;
<a name="l00330"></a>00330             <span class="keywordflow">if</span> (dest&lt;0)dest+=size;  
<a name="l00331"></a>00331             <span class="keywordflow">if</span>(size&gt;1){
<a name="l00332"></a>00332                 MPI_Buffer_attach(buf,bsize);
<a name="l00333"></a>00333                 MPI_Bsend(outletsX, nxy, MPI_INT, dest, 0, MCW);
<a name="l00334"></a>00334                 MPI_Buffer_detach(&amp;ptr,&amp;place);
<a name="l00335"></a>00335                 MPI_Buffer_attach(buf,bsize);
<a name="l00336"></a>00336                 MPI_Bsend(outletsY, nxy, MPI_INT, dest, 1, MCW);
<a name="l00337"></a>00337                 MPI_Buffer_detach(&amp;ptr,&amp;place);
<a name="l00338"></a>00338                 MPI_Buffer_attach(lbuf,lsize);
<a name="l00339"></a>00339                 MPI_Bsend(dist_moved, nxy, MPI_LONG, dest, 3, MCW);
<a name="l00340"></a>00340                 MPI_Buffer_detach(&amp;ptr,&amp;place);
<a name="l00341"></a>00341                 MPI_Recv(toutletsX, nxy, MPI_INT, MPI_ANY_SOURCE, 0, MCW, &amp;status);
<a name="l00342"></a>00342                 MPI_Recv(toutletsY, nxy, MPI_INT, MPI_ANY_SOURCE, 1, MCW, &amp;status);
<a name="l00343"></a>00343                 MPI_Recv(tdist_moved, nxy, MPI_LONG, MPI_ANY_SOURCE, 3, MCW, &amp;status);
<a name="l00344"></a>00344             }
<a name="l00345"></a>00345             <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00346"></a>00346                 <span class="comment">//if a node in the temp arrays belongs to us, and we don&#39;t already have it, get it</span>
<a name="l00347"></a>00347                 flowData-&gt;globalToLocal(toutletsX[i], toutletsY[i], txn, tyn);  <span class="comment">//DGT with single partition this is being passed uninitialized information</span>
<a name="l00348"></a>00348                 flowData-&gt;globalToLocal(outletsX[i], outletsY[i], tx, ty);
<a name="l00349"></a>00349                 <span class="keywordflow">if</span>(flowData-&gt;isInPartition(txn,tyn) &amp;&amp; !(part_has[i]==rank)){  <span class="comment">// if an outlet not in partition is now in partition - grab it</span>
<a name="l00350"></a>00350                     outletsX[i]=toutletsX[i];
<a name="l00351"></a>00351                     outletsY[i]=toutletsY[i];
<a name="l00352"></a>00352                     part_has[i]=rank;
<a name="l00353"></a>00353                     dist_moved[i]=tdist_moved[i];
<a name="l00354"></a>00354                 }
<a name="l00355"></a>00355             }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357             dest = rank+1;
<a name="l00358"></a>00358             <span class="keywordflow">if</span> (dest&gt;=size)dest-=size;  <span class="comment">//DGT Why is this here.  </span>
<a name="l00359"></a>00359             <span class="keywordflow">if</span>(size&gt;1){
<a name="l00360"></a>00360                 MPI_Buffer_attach(buf,bsize);
<a name="l00361"></a>00361                 MPI_Bsend(outletsX, nxy, MPI_INT, dest, 4, MCW);
<a name="l00362"></a>00362                 MPI_Buffer_detach(&amp;ptr,&amp;place);
<a name="l00363"></a>00363                 MPI_Buffer_attach(buf,bsize);
<a name="l00364"></a>00364                 MPI_Bsend(outletsY, nxy, MPI_INT, dest, 5, MCW);
<a name="l00365"></a>00365                 MPI_Buffer_detach(&amp;ptr,&amp;place);
<a name="l00366"></a>00366                 MPI_Buffer_attach(lbuf,lsize);
<a name="l00367"></a>00367                 MPI_Bsend(dist_moved, nxy, MPI_LONG, dest, 7, MCW);
<a name="l00368"></a>00368                 MPI_Buffer_detach(&amp;ptr,&amp;place);
<a name="l00369"></a>00369                 MPI_Recv(toutletsX, nxy, MPI_INT, MPI_ANY_SOURCE, 4, MCW, &amp;status);
<a name="l00370"></a>00370                 MPI_Recv(toutletsY, nxy, MPI_INT, MPI_ANY_SOURCE, 5, MCW, &amp;status);
<a name="l00371"></a>00371                 MPI_Recv(tdist_moved, nxy, MPI_LONG, MPI_ANY_SOURCE, 7, MCW, &amp;status);
<a name="l00372"></a>00372             }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374             <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00375"></a>00375                 <span class="comment">//if a node in the temp arrays belongs to us, and we don&#39;t already have it, get it</span>
<a name="l00376"></a>00376                 flowData-&gt;globalToLocal(toutletsX[i], toutletsY[i], txn, tyn);
<a name="l00377"></a>00377                 flowData-&gt;globalToLocal(outletsX[i], outletsY[i], tx, ty);
<a name="l00378"></a>00378                 <span class="keywordflow">if</span>(flowData-&gt;isInPartition(txn,tyn) &amp;&amp; !(part_has[i]==rank)){
<a name="l00379"></a>00379                     outletsX[i]=toutletsX[i];
<a name="l00380"></a>00380                     outletsY[i]=toutletsY[i];
<a name="l00381"></a>00381                     dist_moved[i]=tdist_moved[i];
<a name="l00382"></a>00382                 }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384             }
<a name="l00385"></a>00385             <span class="keyword">delete</span> [] toutletsX;
<a name="l00386"></a>00386             <span class="keyword">delete</span> [] toutletsY;
<a name="l00387"></a>00387             <span class="keyword">delete</span> [] tdist_moved;
<a name="l00388"></a>00388 
<a name="l00389"></a>00389             <span class="comment">// each process figures out how many nodes it currently has and how many are done</span>
<a name="l00390"></a>00390             localnodes = 0;
<a name="l00391"></a>00391             localdone = 0;
<a name="l00392"></a>00392             <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00393"></a>00393                 flowData-&gt;globalToLocal(outletsX[i], outletsY[i], tx, ty);
<a name="l00394"></a>00394                 <span class="keywordflow">if</span>(flowData-&gt;isInPartition(tx,ty)){
<a name="l00395"></a>00395                     localnodes++;
<a name="l00396"></a>00396                     td=srcData-&gt;getData(tx,ty,td);
<a name="l00397"></a>00397                     <span class="comment">//td = (char) td; </span>
<a name="l00398"></a>00398                     <span class="keywordflow">if</span>(td&gt;=itresh &amp;&amp; ! srcData-&gt;isNodata(tx,ty))localdone++;
<a name="l00399"></a>00399                     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(dist_moved[i]&lt;0)localdone++;  <span class="comment">// DGT added this as a termination condition</span>
<a name="l00400"></a>00400                 }
<a name="l00401"></a>00401             }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403             <span class="comment">//total up all the nodes and all the finished nodes</span>
<a name="l00404"></a>00404             MPI_Reduce(&amp;localnodes, &amp;totalnodes, 1, MPI_INT, MPI_SUM, 0, MCW);
<a name="l00405"></a>00405             MPI_Reduce(&amp;localdone, &amp;totaldone, 1, MPI_INT, MPI_SUM, 0, MCW);
<a name="l00406"></a>00406             <span class="comment">//if(!rank)printf(&quot;dist = %d\tfinished %d out of %d nodes.\n&quot;,dist, totaldone,totalnodes);</span>
<a name="l00407"></a>00407 
<a name="l00408"></a>00408             <span class="comment">//if all the nodes are done or we&#39;ve moved them all maxdist, terminate the loop</span>
<a name="l00409"></a>00409             <span class="keywordflow">if</span>(rank==0){
<a name="l00410"></a>00410                 <span class="keywordflow">if</span>(totaldone==totalnodes){  
<a name="l00411"></a>00411                     done=1;
<a name="l00412"></a>00412                 }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414             }
<a name="l00415"></a>00415             MPI_Bcast(&amp;done,1,MPI_INT,0,MCW);
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418         <span class="comment">// look for unresolved outlets, set dist_moved to -1</span>
<a name="l00419"></a>00419         <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00420"></a>00420             flowData-&gt;globalToLocal(outletsX[i], outletsY[i], tx, ty);
<a name="l00421"></a>00421             <span class="keywordflow">if</span>(flowData-&gt;isInPartition(tx,ty)){
<a name="l00422"></a>00422                 td=srcData-&gt;getData(tx,ty,td);
<a name="l00423"></a>00423                 <span class="keywordflow">if</span>(td&lt;itresh &amp;&amp; dist_moved[i]==maxdist){
<a name="l00424"></a>00424                     dist_moved[i]=-1;
<a name="l00425"></a>00425                     <span class="comment">//              ismoved[i]=0;</span>
<a name="l00426"></a>00426                 }
<a name="l00427"></a>00427             }
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430         <span class="comment">// oooooooooooooooooooooo  end  processing</span>
<a name="l00431"></a>00431 
<a name="l00432"></a>00432         <span class="comment">// write the shapefile that contains the moved src points</span>
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 
<a name="l00435"></a>00435         <span class="keywordtype">double</span> *tempxnode, *tempynode;
<a name="l00436"></a>00436         <span class="keywordtype">long</span>  *tempdist_moved;  <span class="comment">//  *tempismoved,</span>
<a name="l00437"></a>00437         tempxnode = <span class="keyword">new</span> <span class="keywordtype">double</span>[nxy];
<a name="l00438"></a>00438         tempynode = <span class="keyword">new</span> <span class="keywordtype">double</span>[nxy];
<a name="l00439"></a>00439         <span class="comment">//  tempismoved = new long[nxy];</span>
<a name="l00440"></a>00440         tempdist_moved = <span class="keyword">new</span> <span class="keywordtype">long</span>[nxy];
<a name="l00441"></a>00441 
<a name="l00442"></a>00442         <span class="keywordflow">for</span>(i=0;i&lt;nxy;++i){
<a name="l00443"></a>00443             tempxnode[i]=0;
<a name="l00444"></a>00444             tempynode[i]=0;
<a name="l00445"></a>00445             <span class="comment">//      tempismoved[i]=0;</span>
<a name="l00446"></a>00446             tempdist_moved[i]=0;
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         <span class="comment">//if(!rank)printf(&quot;setting up temp arrays...&quot;,dist, totaldone,totalnodes);</span>
<a name="l00450"></a>00450         <span class="comment">// set temp arrays with local data in each process</span>
<a name="l00451"></a>00451         <span class="comment">// each local array should have it&#39;s local data in the array at the proper place</span>
<a name="l00452"></a>00452         <span class="comment">// zeros elsewhere</span>
<a name="l00453"></a>00453         <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00454"></a>00454             p.globalXYToGeo(outletsX[i], outletsY[i], xnode[i], ynode[i]);
<a name="l00455"></a>00455             flowData-&gt;globalToLocal(outletsX[i], outletsY[i], tx, ty);
<a name="l00456"></a>00456             <span class="keywordflow">if</span>(flowData-&gt;isInPartition(tx,ty)){
<a name="l00457"></a>00457                 tempxnode[i]=xnode[i];
<a name="l00458"></a>00458                 tempynode[i]=ynode[i];
<a name="l00459"></a>00459                 <span class="comment">//          tempismoved[i]=ismoved[i];</span>
<a name="l00460"></a>00460                 tempdist_moved[i]=dist_moved[i];
<a name="l00461"></a>00461                 <span class="comment">/*</span>
<a name="l00462"></a>00462 <span class="comment">                printf(&quot;p%d:\t&quot;,rank);</span>
<a name="l00463"></a>00463 <span class="comment">                printf(&quot;x:%d\t&quot;,outletsX[i]);</span>
<a name="l00464"></a>00464 <span class="comment">                printf(&quot;y:%d\t&quot;,outletsY[i]);</span>
<a name="l00465"></a>00465 <span class="comment">                printf(&quot;strm:%d\t&quot;,td);</span>
<a name="l00466"></a>00466 <span class="comment">                printf(&quot;dir:%d\t&quot;,tf);</span>
<a name="l00467"></a>00467 <span class="comment">                printf(&quot;distmvd:%d\t&quot;,dist_moved[i]);</span>
<a name="l00468"></a>00468 <span class="comment">                printf(&quot;ismoved:%d\t&quot;,ismoved[i]);</span>
<a name="l00469"></a>00469 <span class="comment">                printf(&quot;\n&quot;);</span>
<a name="l00470"></a>00470 <span class="comment">                */</span>
<a name="l00471"></a>00471             }
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473         <span class="keywordflow">if</span>(!rank){
<a name="l00474"></a>00474             <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00475"></a>00475                 <span class="comment">// if the outlet is outside the DEM, p0 puts it back in the temp array</span>
<a name="l00476"></a>00476                 <span class="keywordflow">if</span>(outletsX[i]&lt;0||outletsX[i]&gt;=pTotalX||outletsY[i]&lt;0||outletsY[i]&gt;=pTotalY){
<a name="l00477"></a>00477                     tempxnode[i]=origxnode[i];
<a name="l00478"></a>00478                     tempynode[i]=origynode[i];
<a name="l00479"></a>00479                     <span class="comment">//          tempismoved[i]=0;</span>
<a name="l00480"></a>00480                     tempdist_moved[i]=-1;
<a name="l00481"></a>00481                 } 
<a name="l00482"></a>00482                 <span class="comment">// if dist_moved == 0, use original points</span>
<a name="l00483"></a>00483             }
<a name="l00484"></a>00484         }
<a name="l00485"></a>00485         <span class="comment">//if(!rank)printf(&quot;done.\n&quot;,dist, totaldone,totalnodes);</span>
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="comment">//if(!rank)printf(&quot;reducing data...&quot;,dist, totaldone,totalnodes);</span>
<a name="l00489"></a>00489         MPI_Reduce(tempxnode, xnode, nxy, MPI_DOUBLE, MPI_SUM, 0, MCW);
<a name="l00490"></a>00490         MPI_Reduce(tempynode, ynode, nxy, MPI_DOUBLE, MPI_SUM, 0, MCW);
<a name="l00491"></a>00491         <span class="comment">//  MPI_Reduce(tempismoved, ismoved, nxy, MPI_LONG, MPI_SUM, 0, MCW);</span>
<a name="l00492"></a>00492         MPI_Reduce(tempdist_moved, dist_moved, nxy, MPI_LONG, MPI_SUM, 0, MCW);
<a name="l00493"></a>00493         <span class="comment">//if(!rank)printf(&quot;done\n.&quot;,dist, totaldone,totalnodes);</span>
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         <span class="keywordflow">if</span>(!rank){
<a name="l00496"></a>00496             <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00497"></a>00497                 <span class="comment">// if the distance moved is 0, use original x y</span>
<a name="l00498"></a>00498                 <span class="keywordflow">if</span>(dist_moved[i]&lt;=0){  <span class="comment">// DGT changed condition to dist_moved &lt;=0 because original values kept whenever not moved for whatever reason</span>
<a name="l00499"></a>00499                     xnode[i]=origxnode[i];
<a name="l00500"></a>00500                     ynode[i]=origynode[i];
<a name="l00501"></a>00501                 } 
<a name="l00502"></a>00502             }
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         <span class="keyword">delete</span> [] tempxnode;
<a name="l00506"></a>00506         <span class="keyword">delete</span> [] tempynode;
<a name="l00507"></a>00507         <span class="comment">//  delete [] tempismoved;</span>
<a name="l00508"></a>00508         <span class="keyword">delete</span> [] tempdist_moved;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         <span class="comment">//if(!rank)printf(&quot;inserting shapes...&quot;,dist, totaldone,totalnodes);</span>
<a name="l00511"></a>00511         <span class="comment">//if(rank==0)printf(&quot;--\n&quot;);</span>
<a name="l00512"></a>00512         <span class="keywordflow">if</span>(rank==0){
<a name="l00513"></a>00513             <span class="keywordflow">for</span>(i=0;i&lt;nxy;++i){
<a name="l00514"></a>00514                 <span class="keywordtype">double</span> x = xnode[i];  <span class="comment">// DGT says does not need +pdx/2.0;</span>
<a name="l00515"></a>00515                 <span class="keywordtype">double</span> y = ynode[i];  <span class="comment">// DGT +pdy/2.0;</span>
<a name="l00516"></a>00516                 SHPObject *shpmoved = SHPCreateSimpleObject(SHPT_POINT, 1, &amp;x, &amp;y, NULL);
<a name="l00517"></a>00517                 <span class="comment">//if(rank==0)printf(&quot;x: %g \ty: %g\n&quot;,xnode[i],ynode[i]);</span>
<a name="l00518"></a>00518                 <span class="comment">//if(rank==0)printf(&quot;x: %g \ty: %g\tdist: %d\n&quot;,shpmoved-&gt;padfX[0],shpmoved-&gt;padfY[0],dist_moved[i]);</span>
<a name="l00519"></a>00519                 <span class="keywordtype">int</span> shapeIndx = SHPWriteObject(shmoved, -1, shpmoved);
<a name="l00520"></a>00520                 SHPDestroyObject(shpmoved);
<a name="l00521"></a>00521                 <span class="keywordtype">int</span> res;
<a name="l00522"></a>00522                 <span class="keywordflow">for</span>(j=0;j&lt;nfields;++j){
<a name="l00523"></a>00523                     DBFFieldType type = types[j];
<a name="l00524"></a>00524                     <span class="keywordtype">int</span> fieldIndx = indexMap[j];
<a name="l00525"></a>00525                     <span class="keywordflow">if</span> ((type != FTInvalid) &amp;&amp; (fieldIndx &gt;= 0)) {
<a name="l00526"></a>00526                         <span class="keywordflow">if</span> (type = FTInteger) {
<a name="l00527"></a>00527                             <span class="keywordtype">int</span> val = DBFReadIntegerAttribute(dbf, i, j);
<a name="l00528"></a>00528                             res = DBFWriteIntegerAttribute(dbfmoved, shapeIndx, fieldIndx, val);
<a name="l00529"></a>00529                         } 
<a name="l00530"></a>00530                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == FTDouble) {
<a name="l00531"></a>00531                             <span class="keywordtype">double</span> val = DBFReadDoubleAttribute(dbf, i, j);
<a name="l00532"></a>00532                             res = DBFWriteDoubleAttribute(dbfmoved, shapeIndx, fieldIndx, val);
<a name="l00533"></a>00533                         }
<a name="l00534"></a>00534                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == FTString) {
<a name="l00535"></a>00535                             <span class="keyword">const</span> <span class="keywordtype">char</span> * val = DBFReadStringAttribute(dbf, i, j);
<a name="l00536"></a>00536                             res = DBFWriteStringAttribute(dbfmoved, shapeIndx, fieldIndx, val);
<a name="l00537"></a>00537                         }
<a name="l00538"></a>00538                         <span class="keywordflow">else</span> { <span class="comment">// FTLogical:</span>
<a name="l00539"></a>00539                             <span class="keyword">const</span> <span class="keywordtype">char</span> * val = DBFReadLogicalAttribute(dbf, i, j);
<a name="l00540"></a>00540                             res = DBFWriteLogicalAttribute(dbfmoved, shapeIndx, fieldIndx, val[0]);
<a name="l00541"></a>00541                         }
<a name="l00542"></a>00542                     }
<a name="l00543"></a>00543                     <span class="comment">// CWG should check res is not zero</span>
<a name="l00544"></a>00544                 }
<a name="l00545"></a>00545                 <span class="comment">//  Add distance moved value</span>
<a name="l00546"></a>00546                 res = DBFWriteIntegerAttribute(dbfmoved, i, dmIndex, (<span class="keywordtype">int</span>)dist_moved[i]);
<a name="l00547"></a>00547                 <span class="comment">// CWG should check res is not zero</span>
<a name="l00548"></a>00548             }
<a name="l00549"></a>00549             <span class="comment">//if(!rank)printf(&quot;closing file...&quot;,dist, totaldone,totalnodes);</span>
<a name="l00550"></a>00550             <span class="keyword">delete</span> [] indexMap;
<a name="l00551"></a>00551             <span class="keyword">delete</span> [] types;
<a name="l00552"></a>00552             SHPClose(sh);
<a name="l00553"></a>00553             DBFClose(dbf);
<a name="l00554"></a>00554             SHPClose(shmoved);
<a name="l00555"></a>00555             DBFClose(dbfmoved);
<a name="l00556"></a>00556         }
<a name="l00557"></a>00557         <span class="comment">//if(!rank)printf(&quot;done\n.&quot;,dist, totaldone,totalnodes);</span>
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 
<a name="l00560"></a>00560         <span class="keyword">delete</span> [] xnode;
<a name="l00561"></a>00561         <span class="keyword">delete</span> [] ynode;
<a name="l00562"></a>00562         <span class="comment">//  delete [] ismoved;</span>
<a name="l00563"></a>00563         <span class="keyword">delete</span> [] dist_moved;
<a name="l00564"></a>00564         <span class="keyword">delete</span> [] outletsX;
<a name="l00565"></a>00565         <span class="keyword">delete</span> [] outletsY;
<a name="l00566"></a>00566         <span class="keyword">delete</span> [] part_has;
<a name="l00567"></a>00567         end = MPI_Wtime();
<a name="l00568"></a>00568         <span class="keywordtype">double</span> total,temp;
<a name="l00569"></a>00569         total = end-begin;
<a name="l00570"></a>00570         MPI_Allreduce (&amp;total, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00571"></a>00571         total = temp/size;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 
<a name="l00574"></a>00574         <span class="keywordflow">if</span>( rank == 0) 
<a name="l00575"></a>00575             printf(<span class="stringliteral">&quot;Total time: %f\n&quot;</span>,total);
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     }MPI_Finalize();
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 
<a name="l00580"></a>00580     <span class="keywordflow">return</span> 0;
<a name="l00581"></a>00581 }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->

</div>
</div>
</div>
</div>
</div>

<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 13 2016 11:04:21 for SEIMS-2016 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="$relpath^doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
