<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.7.6.1"/>
        
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>

        <title>SEIMS-2016: preprocess/cpp_src/TauDEM/streamnet.cpp Source File</title>
        
        <!--<link href="$relpath^tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="$relpath^dynsections.js"></script>
        
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

        <link href="$relpath^doxygen.css" rel="stylesheet" type="text/css" />
        $extrastylesheet

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="$relpath^doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">SEIMS-2016 1.0-beta</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">preprocess/cpp_src/TauDEM/streamnet.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*  StreamNet function to compute stream networks based on d8 directions.</span>
<a name="l00002"></a>00002 <span class="comment">     </span>
<a name="l00003"></a>00003 <span class="comment">  David Tarboton, Dan Watson, Jeremy Neff</span>
<a name="l00004"></a>00004 <span class="comment">  Utah State University  </span>
<a name="l00005"></a>00005 <span class="comment">  May 23, 2010 </span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">*/</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="comment">/*  Copyright (C) 2010  David Tarboton, Utah State University</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">This program is free software; you can redistribute it and/or</span>
<a name="l00012"></a>00012 <span class="comment">modify it under the terms of the GNU General Public License </span>
<a name="l00013"></a>00013 <span class="comment">version 2, 1991 as published by the Free Software Foundation.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">This program is distributed in the hope that it will be useful,</span>
<a name="l00016"></a>00016 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00017"></a>00017 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00018"></a>00018 <span class="comment">GNU General Public License for more details.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">A copy of the full GNU General Public License is included in file </span>
<a name="l00021"></a>00021 <span class="comment">gpl.html. This is also available at:</span>
<a name="l00022"></a>00022 <span class="comment">http://www.gnu.org/copyleft/gpl.html</span>
<a name="l00023"></a>00023 <span class="comment">or from:</span>
<a name="l00024"></a>00024 <span class="comment">The Free Software Foundation, Inc., 59 Temple Place - Suite 330, </span>
<a name="l00025"></a>00025 <span class="comment">Boston, MA  02111-1307, USA.</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">If you wish to use or incorporate this program (or parts of it) into </span>
<a name="l00028"></a>00028 <span class="comment">other software that does not meet the GNU General Public License </span>
<a name="l00029"></a>00029 <span class="comment">conditions contact the author to request permission.</span>
<a name="l00030"></a>00030 <span class="comment">David G. Tarboton  </span>
<a name="l00031"></a>00031 <span class="comment">Utah State University </span>
<a name="l00032"></a>00032 <span class="comment">8200 Old Main Hill </span>
<a name="l00033"></a>00033 <span class="comment">Logan, UT 84322-8200 </span>
<a name="l00034"></a>00034 <span class="comment">USA </span>
<a name="l00035"></a>00035 <span class="comment">http://www.engineering.usu.edu/dtarb/ </span>
<a name="l00036"></a>00036 <span class="comment">email:  dtarb@usu.edu </span>
<a name="l00037"></a>00037 <span class="comment">*/</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="comment">//  This software is distributed from http://hydrology.usu.edu/taudem/</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">// 1/25/14.  Modified to use shapelib by Chris George</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;commonLib.h&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;linearpart.h&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;createpart.h&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;tiffIO.h&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;tardemlib.h&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;linklib.h&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;streamnet.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00058"></a>00058 <span class="keyword">using namespace </span>std;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 SHPHandle shp1;
<a name="l00061"></a>00061 DBFHandle dbf1;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="keywordtype">int</span> linknoIdx, dslinknoIdx, uslinkno1Idx, uslinkno2Idx, dsnodeidIdx, orderIdx, lengthIdx, magnitudeIdx, dscontareaIdx, 
<a name="l00064"></a>00064     dropIdx, slopeIdx, straightlengthIdx, uscontareaIdx, wsnoIdx, doutendIdx, doutstartIdx, doutmidIdx;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keywordtype">void</span> createStreamNetShapefile(<span class="keywordtype">char</span> *streamnetshp)
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068     shp1 = SHPCreate(streamnetshp, SHPT_ARC);
<a name="l00069"></a>00069     <span class="keywordtype">char</span> streamnetdbf[MAXLN];
<a name="l00070"></a>00070     nameadd(streamnetdbf, streamnetshp, <span class="stringliteral">&quot;.dbf&quot;</span>);
<a name="l00071"></a>00071     dbf1 = DBFCreate(streamnetdbf);
<a name="l00072"></a>00072     linknoIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;LINKNO&quot;</span>,FTInteger,6,0);
<a name="l00073"></a>00073     dslinknoIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;DSLINKNO&quot;</span>,FTInteger,6,0);
<a name="l00074"></a>00074     uslinkno1Idx = DBFAddField(dbf1,<span class="stringliteral">&quot;USLINKNO1&quot;</span>,FTInteger,6,0);
<a name="l00075"></a>00075     uslinkno2Idx = DBFAddField(dbf1,<span class="stringliteral">&quot;USLINKNO2&quot;</span>,FTInteger,6,0);
<a name="l00076"></a>00076     dsnodeidIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;DSNODEID&quot;</span>,FTInteger,12,0);
<a name="l00077"></a>00077     orderIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;Order&quot;</span>,FTInteger,6,0);
<a name="l00078"></a>00078     lengthIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;Length&quot;</span>,FTDouble,16,1);
<a name="l00079"></a>00079     magnitudeIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;Magnitude&quot;</span>,FTInteger,6,0);
<a name="l00080"></a>00080     dscontareaIdx  = DBFAddField(dbf1,<span class="stringliteral">&quot;DS_Cont_Area&quot;</span>,FTDouble,16,1);
<a name="l00081"></a>00081     dropIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;Drop&quot;</span>,FTDouble,16,2);
<a name="l00082"></a>00082     slopeIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;Slope&quot;</span>,FTDouble,16,12);
<a name="l00083"></a>00083     straightlengthIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;Straight_Length&quot;</span>,FTDouble,16,1);
<a name="l00084"></a>00084     uscontareaIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;US_Cont_Area&quot;</span>,FTDouble,16,1);
<a name="l00085"></a>00085     wsnoIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;WSNO&quot;</span>,FTInteger,6,0);
<a name="l00086"></a>00086     doutendIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;DOUT_END&quot;</span>,FTDouble,16,1);
<a name="l00087"></a>00087     doutstartIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;DOUT_START&quot;</span>,FTDouble,16,1);
<a name="l00088"></a>00088     doutmidIdx = DBFAddField(dbf1,<span class="stringliteral">&quot;DOUT_MID&quot;</span>,FTDouble,16,1);
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">// Write shape from tardemlib.cpp</span>
<a name="l00092"></a>00092 <span class="keywordtype">int</span> reachshape(<span class="keywordtype">long</span> *cnet,<span class="keywordtype">float</span> *lengthd, <span class="keywordtype">float</span> *elev, <span class="keywordtype">float</span> *area, <span class="keywordtype">double</span> *pointx, <span class="keywordtype">double</span> *pointy, <span class="keywordtype">long</span> np)
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094 <span class="comment">// Function to write stream network shapefile</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     <span class="keywordtype">int</span> nVertices;
<a name="l00097"></a>00097     <span class="keywordflow">if</span> (np &lt; 2) {<span class="comment">//singleton - will be duplicated</span>
<a name="l00098"></a>00098         nVertices = 2;
<a name="l00099"></a>00099     }
<a name="l00100"></a>00100     <span class="keywordflow">else</span> {
<a name="l00101"></a>00101         nVertices = np;
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103      
<a name="l00104"></a>00104     <span class="keywordtype">double</span> *mypointx = <span class="keyword">new</span> <span class="keywordtype">double</span>[nVertices];
<a name="l00105"></a>00105     <span class="keywordtype">double</span> *mypointy = <span class="keyword">new</span> <span class="keywordtype">double</span>[nVertices];
<a name="l00106"></a>00106 
<a name="l00107"></a>00107     <span class="keywordtype">double</span> x,y,length,glength,x1,y1,xlast,ylast,usarea,dsarea,dslast,dl,drop,slope;
<a name="l00108"></a>00108     <span class="keywordtype">int</span> istart,iend,j;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     istart=cnet[1];  <span class="comment">//  start coord for first link</span>
<a name="l00111"></a>00111     iend=cnet[2];<span class="comment">//  end coord for first link</span>
<a name="l00112"></a>00112     x1=pointx[0];
<a name="l00113"></a>00113     y1=pointy[0];
<a name="l00114"></a>00114     length=0.;
<a name="l00115"></a>00115     xlast=x1;
<a name="l00116"></a>00116     ylast=y1;
<a name="l00117"></a>00117     usarea=area[0];
<a name="l00118"></a>00118     dslast=usarea;
<a name="l00119"></a>00119     dsarea=usarea;
<a name="l00120"></a>00120     <span class="keywordtype">long</span> prt = 0;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     <span class="keywordflow">for</span>(j=0; j&lt;np; j++)  <span class="comment">//  loop over points</span>
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124         x=pointx[j];
<a name="l00125"></a>00125         y=pointy[j];
<a name="l00126"></a>00126         <span class="comment">// we have to reverse order of pointx and pointy arrays to finish up with </span>
<a name="l00127"></a>00127         <span class="comment">// the point with point index 0 in the shape being the outlet point</span>
<a name="l00128"></a>00128         <span class="comment">// (which is for backwards compatibility with previous versions of TauDEM)</span>
<a name="l00129"></a>00129         <span class="keywordtype">int</span> i = np - (j + 1);
<a name="l00130"></a>00130         mypointx[i] = x;
<a name="l00131"></a>00131         mypointy[i] = y;
<a name="l00132"></a>00132         dl=sqrt((x-xlast)*(x-xlast)+(y-ylast)*(y-ylast));
<a name="l00133"></a>00133         <span class="keywordflow">if</span>(dl &gt; 0.)
<a name="l00134"></a>00134         {
<a name="l00135"></a>00135             length=length+dl;
<a name="l00136"></a>00136             xlast=x;  ylast=y;
<a name="l00137"></a>00137             dsarea=dslast;   <span class="comment">// keeps track of last ds area</span>
<a name="l00138"></a>00138             dslast=area[j];
<a name="l00139"></a>00139         }
<a name="l00140"></a>00140     }
<a name="l00141"></a>00141     drop=elev[0]-elev[np-1];
<a name="l00142"></a>00142     slope=0.;
<a name="l00143"></a>00143     <span class="keywordtype">float</span> dsdist=lengthd[np-1];
<a name="l00144"></a>00144     <span class="keywordtype">float</span> usdist=lengthd[0];
<a name="l00145"></a>00145     <span class="keywordtype">float</span> middist=(dsdist+usdist)*0.5;
<a name="l00146"></a>00146     <span class="keywordflow">if</span>(length &gt; 0.)slope=drop/length;
<a name="l00147"></a>00147     glength=sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));
<a name="l00148"></a>00148 
<a name="l00149"></a>00149     <span class="comment">// ensure at least two points (assuming have at least 1) by repeating singleton</span>
<a name="l00150"></a>00150     <span class="keywordflow">if</span> (np &lt; 2) {
<a name="l00151"></a>00151         mypointx[1] = mypointx[0];
<a name="l00152"></a>00152         mypointy[1] = mypointy[0];
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155     SHPObject *shape = SHPCreateSimpleObject(
<a name="l00156"></a>00156         SHPT_ARC,                       <span class="comment">// type</span>
<a name="l00157"></a>00157         nVertices,                      <span class="comment">// number of vertices</span>
<a name="l00158"></a>00158         mypointx,                       <span class="comment">// X values</span>
<a name="l00159"></a>00159         mypointy,                       <span class="comment">// Y values</span>
<a name="l00160"></a>00160         NULL);                          <span class="comment">// Z values</span>
<a name="l00161"></a>00161     
<a name="l00162"></a>00162     <span class="comment">// -1 position means append</span>
<a name="l00163"></a>00163     <span class="keywordtype">int</span> ishape = SHPWriteObject(shp1, -1, shape);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     SHPDestroyObject(shape);
<a name="l00166"></a>00166     <span class="keyword">delete</span>[] mypointx;
<a name="l00167"></a>00167     <span class="keyword">delete</span>[] mypointy;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <span class="keywordtype">int</span> res;
<a name="l00170"></a>00170     res = DBFWriteIntegerAttribute(dbf1, ishape, linknoIdx, (<span class="keywordtype">int</span>)cnet[0]);
<a name="l00171"></a>00171     res *= DBFWriteIntegerAttribute(dbf1, ishape, dslinknoIdx, (<span class="keywordtype">int</span>)cnet[3]);
<a name="l00172"></a>00172     res *= DBFWriteIntegerAttribute(dbf1, ishape, uslinkno1Idx, (<span class="keywordtype">int</span>)cnet[4]);
<a name="l00173"></a>00173     res *= DBFWriteIntegerAttribute(dbf1, ishape, uslinkno2Idx, (<span class="keywordtype">int</span>)cnet[5]);
<a name="l00174"></a>00174     res *= DBFWriteIntegerAttribute(dbf1, ishape, dsnodeidIdx, (<span class="keywordtype">int</span>)cnet[7]);
<a name="l00175"></a>00175     res *= DBFWriteIntegerAttribute(dbf1, ishape, orderIdx, (<span class="keywordtype">int</span>)cnet[6]);
<a name="l00176"></a>00176     res *= DBFWriteDoubleAttribute(dbf1, ishape, lengthIdx, length);
<a name="l00177"></a>00177     res *= DBFWriteIntegerAttribute(dbf1, ishape, magnitudeIdx, (<span class="keywordtype">int</span>)cnet[8]);
<a name="l00178"></a>00178     res *= DBFWriteDoubleAttribute(dbf1, ishape, dscontareaIdx, dsarea);
<a name="l00179"></a>00179     res *= DBFWriteDoubleAttribute(dbf1, ishape, dropIdx, drop);
<a name="l00180"></a>00180     res *= DBFWriteDoubleAttribute(dbf1, ishape, slopeIdx, slope);
<a name="l00181"></a>00181     res *= DBFWriteDoubleAttribute(dbf1, ishape, straightlengthIdx, glength);
<a name="l00182"></a>00182     res *= DBFWriteDoubleAttribute(dbf1, ishape, uscontareaIdx, usarea);
<a name="l00183"></a>00183     res *= DBFWriteIntegerAttribute(dbf1, ishape, wsnoIdx, (<span class="keywordtype">int</span>)cnet[0]);
<a name="l00184"></a>00184     res *= DBFWriteDoubleAttribute(dbf1, ishape, doutendIdx, dsdist);
<a name="l00185"></a>00185     res *= DBFWriteDoubleAttribute(dbf1, ishape, doutstartIdx, usdist);
<a name="l00186"></a>00186     res *= DBFWriteDoubleAttribute(dbf1, ishape, doutmidIdx, middist);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     <span class="keywordflow">if</span> (res == 0) { <span class="comment">// at least one of the write attribute functions returned 0, ie failed</span>
<a name="l00189"></a>00189         fprintf(stderr, <span class="stringliteral">&quot;Problem writing to stream network dbf file&quot;</span>);
<a name="l00190"></a>00190         fflush(stderr);
<a name="l00191"></a>00191         <span class="keywordflow">return</span> 1;
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193     <span class="keywordflow">return</span> 0;
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="keyword">struct </span>Slink{
<a name="l00197"></a>00197     <span class="keywordtype">long</span> id;
<a name="l00198"></a>00198     <span class="keywordtype">short</span> dest;
<a name="l00199"></a>00199 };
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="keywordtype">int</span> netsetup(<span class="keywordtype">char</span> *pfile,<span class="keywordtype">char</span> *srcfile,<span class="keywordtype">char</span> *ordfile,<span class="keywordtype">char</span> *ad8file,<span class="keywordtype">char</span> *elevfile,<span class="keywordtype">char</span> *treefile, <span class="keywordtype">char</span> *coordfile, 
<a name="l00202"></a>00202              <span class="keywordtype">char</span> *outletshapefile, <span class="keywordtype">char</span> *wfile, <span class="keywordtype">char</span> *streamnetshp, <span class="keywordtype">long</span> useOutlets, <span class="keywordtype">long</span> ordert, <span class="keywordtype">bool</span> verbose) 
<a name="l00203"></a>00203 {
<a name="l00204"></a>00204     <span class="comment">// MPI Init section</span>
<a name="l00205"></a>00205     MPI_Init(NULL,NULL);{
<a name="l00206"></a>00206         <span class="keywordtype">int</span> rank,size;
<a name="l00207"></a>00207         MPI_Comm_rank(MCW,&amp;rank);
<a name="l00208"></a>00208         MPI_Comm_size(MCW,&amp;size);
<a name="l00209"></a>00209         <span class="keywordflow">if</span>(rank==0)
<a name="l00210"></a>00210             {
<a name="l00211"></a>00211                 printf(<span class="stringliteral">&quot;StreamNet version %s\n&quot;</span>,TDVERSION);
<a name="l00212"></a>00212                 fflush(stdout);
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         <span class="comment">//  Used throughout</span>
<a name="l00216"></a>00216         <span class="keywordtype">float</span> tempFloat;
<a name="l00217"></a>00217         <span class="keywordtype">long</span> tempLong;
<a name="l00218"></a>00218         <span class="keywordtype">short</span> tempShort;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         <span class="comment">//  Keep track of time</span>
<a name="l00221"></a>00221         <span class="keywordtype">double</span> begint = MPI_Wtime();
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         <span class="comment">//  *** initiate src grid partition from src</span>
<a name="l00224"></a>00224         tiffIO srcIO(srcfile, SHORT_TYPE);  
<a name="l00225"></a>00225         <span class="keywordtype">long</span> TotalX = srcIO.getTotalX();
<a name="l00226"></a>00226         <span class="keywordtype">long</span> TotalY = srcIO.getTotalY();
<a name="l00227"></a>00227         <span class="keywordtype">double</span> dx = srcIO.getdx();
<a name="l00228"></a>00228         <span class="keywordtype">double</span> dy = srcIO.getdy();
<a name="l00229"></a>00229         <span class="keywordtype">double</span> diag=sqrt((dx*dx)+(dy*dy));
<a name="l00230"></a>00230         <span class="comment">//if(rank==0)</span>
<a name="l00231"></a>00231         <span class="comment">//{</span>
<a name="l00232"></a>00232         <span class="comment">//  float timeestimate=(1e-4*TotalX*TotalY/pow((double) size,0.2))/60+1;  // Time estimate in minutes</span>
<a name="l00233"></a>00233         <span class="comment">//  fprintf(stderr,&quot;This run may take on the order of %.0f minutes to complete.\n&quot;,timeestimate);</span>
<a name="l00234"></a>00234         <span class="comment">//  fprintf(stderr,&quot;This estimate is very approximate. \nRun time is highly uncertain as it depends on the complexity of the input data \nand speed and memory of the computer. This estimate is based on our testing on \na dual quad core Dell Xeon E5405 2.0GHz PC with 16GB RAM.\n&quot;);</span>
<a name="l00235"></a>00235         <span class="comment">//  fflush(stderr);</span>
<a name="l00236"></a>00236         <span class="comment">//}</span>
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         <span class="comment">//Create partition and read data</span>
<a name="l00240"></a>00240         tdpartition *src;
<a name="l00241"></a>00241         src = CreateNewPartition(srcIO.getDatatype(), TotalX, TotalY, dx, dy, srcIO.getNodata());
<a name="l00242"></a>00242         <span class="keywordtype">int</span> nx = src-&gt;getnx();
<a name="l00243"></a>00243         <span class="keywordtype">int</span> ny = src-&gt;getny();
<a name="l00244"></a>00244         <span class="keywordtype">int</span> xstart, ystart;  
<a name="l00245"></a>00245         src-&gt;localToGlobal(0, 0, xstart, ystart);  
<a name="l00246"></a>00246         srcIO.read((<span class="keywordtype">long</span>)xstart, (<span class="keywordtype">long</span>)ystart, (<span class="keywordtype">long</span>)ny, (<span class="keywordtype">long</span>)nx, src-&gt;getGridPointer());
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         <span class="comment">//  *** initiate flowdir grid partition from dirfile</span>
<a name="l00249"></a>00249         tiffIO dirIO(pfile, SHORT_TYPE);
<a name="l00250"></a>00250         <span class="keywordflow">if</span>(!dirIO.compareTiff(srcIO)){
<a name="l00251"></a>00251             printf(<span class="stringliteral">&quot;pfile and src files not the same size. Exiting \n&quot;</span>);
<a name="l00252"></a>00252             MPI_Abort(MCW,4);
<a name="l00253"></a>00253         }
<a name="l00254"></a>00254         <span class="comment">//Create partition and read data</span>
<a name="l00255"></a>00255         tdpartition *flowDir;
<a name="l00256"></a>00256         flowDir = CreateNewPartition(dirIO.getDatatype(), TotalX, TotalY, dx, dy, dirIO.getNodata());
<a name="l00257"></a>00257         dirIO.read((<span class="keywordtype">long</span>)xstart, (<span class="keywordtype">long</span>)ystart, (<span class="keywordtype">long</span>)ny, (<span class="keywordtype">long</span>)nx, flowDir-&gt;getGridPointer());
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         tiffIO ad8IO(ad8file, FLOAT_TYPE);
<a name="l00260"></a>00260         <span class="keywordflow">if</span>(!ad8IO.compareTiff(srcIO)){
<a name="l00261"></a>00261             printf(<span class="stringliteral">&quot;ad8file and src files not the same size. Exiting \n&quot;</span>);
<a name="l00262"></a>00262             MPI_Abort(MCW,4);
<a name="l00263"></a>00263         }
<a name="l00264"></a>00264         <span class="comment">//Create partition and read data</span>
<a name="l00265"></a>00265         tdpartition *areaD8;
<a name="l00266"></a>00266         areaD8 = CreateNewPartition(ad8IO.getDatatype(), TotalX, TotalY, dx, dy, ad8IO.getNodata());
<a name="l00267"></a>00267         ad8IO.read((<span class="keywordtype">long</span>)xstart, (<span class="keywordtype">long</span>)ystart, (<span class="keywordtype">long</span>)ny, (<span class="keywordtype">long</span>)nx, areaD8-&gt;getGridPointer());
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         tiffIO elevIO(elevfile, FLOAT_TYPE);
<a name="l00270"></a>00270         <span class="keywordflow">if</span>(!elevIO.compareTiff(srcIO)){
<a name="l00271"></a>00271             printf(<span class="stringliteral">&quot;elevfile and src files not the same size. Exiting \n&quot;</span>);
<a name="l00272"></a>00272             MPI_Abort(MCW,4);
<a name="l00273"></a>00273         }
<a name="l00274"></a>00274         <span class="comment">//Create partition and read data</span>
<a name="l00275"></a>00275         tdpartition *elev;
<a name="l00276"></a>00276         elev = CreateNewPartition(elevIO.getDatatype(), TotalX, TotalY, dx, dy, elevIO.getNodata());
<a name="l00277"></a>00277         elevIO.read((<span class="keywordtype">long</span>)xstart, (<span class="keywordtype">long</span>)ystart, (<span class="keywordtype">long</span>)ny, (<span class="keywordtype">long</span>)nx, elev-&gt;getGridPointer());
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         <span class="comment">//Create empty partition to store new ID information</span>
<a name="l00281"></a>00281         tdpartition *idGrid;
<a name="l00282"></a>00282         idGrid = CreateNewPartition(LONG_TYPE, TotalX, TotalY, dx, dy, MISSINGLONG);
<a name="l00283"></a>00283         <span class="comment">//Create empty partition to store number of contributing neighbors</span>
<a name="l00284"></a>00284         tdpartition *contribs;
<a name="l00285"></a>00285         contribs = CreateNewPartition(SHORT_TYPE, TotalX, TotalY, dx, dy, MISSINGSHORT);
<a name="l00286"></a>00286         <span class="comment">//Create empty partition to stream order</span>
<a name="l00287"></a>00287         tdpartition *wsGrid;
<a name="l00288"></a>00288         wsGrid = CreateNewPartition(LONG_TYPE, TotalX, TotalY, dx, dy, MISSINGLONG);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         makeLinkSet();
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         <span class="keywordtype">long</span> i,j,inext,jnext;
<a name="l00293"></a>00293         <span class="keywordtype">int</span> *xOutlets;
<a name="l00294"></a>00294         <span class="keywordtype">int</span> *yOutlets;
<a name="l00295"></a>00295         <span class="keywordtype">int</span> numOutlets=0;
<a name="l00296"></a>00296         <span class="keywordtype">double</span> *x=NULL;
<a name="l00297"></a>00297         <span class="keywordtype">double</span> *y=NULL;
<a name="l00298"></a>00298         <span class="keywordtype">int</span> *ids=NULL;
<a name="l00299"></a>00299         <span class="comment">// Read outlets </span>
<a name="l00300"></a>00300         <span class="keywordflow">if</span>( useOutlets == 1) {
<a name="l00301"></a>00301             <span class="keywordflow">if</span>(rank==0){
<a name="l00302"></a>00302                 <span class="keywordflow">if</span>(readoutlets(outletshapefile, &amp;numOutlets, x, y,ids) !=0){
<a name="l00303"></a>00303                     printf(<span class="stringliteral">&quot;Exiting \n&quot;</span>);
<a name="l00304"></a>00304                     MPI_Abort(MCW,5);
<a name="l00305"></a>00305                 }<span class="keywordflow">else</span> {
<a name="l00306"></a>00306                     MPI_Bcast(&amp;numOutlets, 1, MPI_INT, 0, MCW);
<a name="l00307"></a>00307                     MPI_Bcast(x, numOutlets, MPI_DOUBLE, 0, MCW);
<a name="l00308"></a>00308                     MPI_Bcast(y, numOutlets, MPI_DOUBLE, 0, MCW);
<a name="l00309"></a>00309                     MPI_Bcast(ids, numOutlets, MPI_INT, 0, MCW);
<a name="l00310"></a>00310                 }
<a name="l00311"></a>00311             }
<a name="l00312"></a>00312             <span class="keywordflow">else</span> {
<a name="l00313"></a>00313                 MPI_Bcast(&amp;numOutlets, 1, MPI_INT, 0, MCW);
<a name="l00314"></a>00314 
<a name="l00315"></a>00315                 <span class="comment">//x = (double*) malloc( sizeof( double ) * numOutlets );</span>
<a name="l00316"></a>00316                 <span class="comment">//y = (double*) malloc( sizeof( double ) * numOutlets );</span>
<a name="l00317"></a>00317                 x = <span class="keyword">new</span> <span class="keywordtype">double</span>[numOutlets];
<a name="l00318"></a>00318                 y = <span class="keyword">new</span> <span class="keywordtype">double</span>[numOutlets];
<a name="l00319"></a>00319                 ids = <span class="keyword">new</span> <span class="keywordtype">int</span>[numOutlets];
<a name="l00320"></a>00320 
<a name="l00321"></a>00321                 MPI_Bcast(x, numOutlets, MPI_DOUBLE, 0, MCW);
<a name="l00322"></a>00322                 MPI_Bcast(y, numOutlets, MPI_DOUBLE, 0, MCW);
<a name="l00323"></a>00323                 MPI_Bcast(ids, numOutlets, MPI_INT, 0, MCW);
<a name="l00324"></a>00324             }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 
<a name="l00327"></a>00327             xOutlets = <span class="keyword">new</span> <span class="keywordtype">int</span>[numOutlets];
<a name="l00328"></a>00328             yOutlets = <span class="keyword">new</span> <span class="keywordtype">int</span>[numOutlets];
<a name="l00329"></a>00329         <span class="comment">//  Loop over all points in shapefile.  If they are in the partition (after conversion from </span>
<a name="l00330"></a>00330         <span class="comment">//   geographic to global, then global to partition coordinates) set the idGrid to hold ids value</span>
<a name="l00331"></a>00331         <span class="comment">//   leaving the remainder of idGrid to no data</span>
<a name="l00332"></a>00332             <span class="keywordflow">for</span>(i = 0; i&lt;numOutlets;i++){
<a name="l00333"></a>00333                 ad8IO.geoToGlobalXY(x[i], y[i], xOutlets[i], yOutlets[i]);
<a name="l00334"></a>00334                 <span class="keywordtype">int</span> xlocal, ylocal;
<a name="l00335"></a>00335                 idGrid-&gt;globalToLocal(xOutlets[i], yOutlets[i],xlocal,ylocal);
<a name="l00336"></a>00336                 <span class="keywordflow">if</span>(idGrid-&gt;isInPartition(xlocal,ylocal)){   <span class="comment">//xOutlets[i], yOutlets[i])){</span>
<a name="l00337"></a>00337                     idGrid-&gt;setData(xlocal,ylocal,(<span class="keywordtype">long</span>)ids[i]);  <span class="comment">//xOutlets[i], yOutlets[i], (long)ids[i]);</span>
<a name="l00338"></a>00338                 }
<a name="l00339"></a>00339             }
<a name="l00340"></a>00340             idGrid-&gt;share();
<a name="l00341"></a>00341         }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343         <span class="comment">// Timer read time</span>
<a name="l00344"></a>00344         <span class="keywordtype">double</span> readt = MPI_Wtime();
<a name="l00345"></a>00345         <span class="keywordflow">if</span>(verbose)  <span class="comment">// debug writes</span>
<a name="l00346"></a>00346         {
<a name="l00347"></a>00347             printf(<span class="stringliteral">&quot;Files read\n&quot;</span>);
<a name="l00348"></a>00348             printf(<span class="stringliteral">&quot;Process: %d, TotalX: %d, TotalY: %d\n&quot;</span>,rank,TotalX,TotalY);
<a name="l00349"></a>00349             printf(<span class="stringliteral">&quot;Process: %d, nx: %d, ny: %d\n&quot;</span>,rank,nx,ny);
<a name="l00350"></a>00350             printf(<span class="stringliteral">&quot;Process: %d, xstart: %d, ystart: %d\n&quot;</span>,rank,xstart,ystart);
<a name="l00351"></a>00351             printf(<span class="stringliteral">&quot;Process: %d, numOutlets: %d\n&quot;</span>,rank,numOutlets);
<a name="l00352"></a>00352             fflush(stdout);
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="comment">//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span>
<a name="l00356"></a>00356 <span class="comment">//  Block to evaluate distance to outlet</span>
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         <span class="comment">//Create empty partition to store lengths</span>
<a name="l00359"></a>00359         tdpartition *lengths;
<a name="l00360"></a>00360         lengths = CreateNewPartition(FLOAT_TYPE, TotalX, TotalY, dx, dy, MISSINGFLOAT);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362         src-&gt;share();
<a name="l00363"></a>00363         flowDir-&gt;share();
<a name="l00364"></a>00364         <span class="keywordflow">if</span>(rank==0)
<a name="l00365"></a>00365         {
<a name="l00366"></a>00366             fprintf(stderr,<span class="stringliteral">&quot;Evaluating distances to outlet\n&quot;</span>);
<a name="l00367"></a>00367             fflush(stderr);
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="comment">//  Initialize queue and contribs partition </span>
<a name="l00372"></a>00372         queue &lt;node&gt; que;
<a name="l00373"></a>00373 <span class="comment">// Initialize queue for links that will be sent.</span>
<a name="l00374"></a>00374         queue &lt;Slink&gt; linkQ;
<a name="l00375"></a>00375         <span class="keywordtype">long</span> Sup = 0;
<a name="l00376"></a>00376         <span class="keywordtype">long</span> Sdown = 0;
<a name="l00377"></a>00377         Slink temp;
<a name="l00378"></a>00378         node t;
<a name="l00379"></a>00379         <span class="keywordtype">int</span> p;
<a name="l00380"></a>00380         <span class="keywordflow">for</span>(j=0;j&lt;ny;++j){
<a name="l00381"></a>00381             <span class="keywordflow">for</span>(i=0;i&lt;nx;++i){
<a name="l00382"></a>00382                 <span class="comment">// If I am on stream and my downslope neighbor is on stream contribs is 1</span>
<a name="l00383"></a>00383                 <span class="comment">// If I am on stream and my downslope neighbor is off stream contribs is 0 because </span>
<a name="l00384"></a>00384                 <span class="comment">//  I am at the end of a stream</span>
<a name="l00385"></a>00385                 <span class="keywordflow">if</span>(!src-&gt;isNodata(i,j) &amp;&amp; src-&gt;getData(i,j,tempShort)&gt;0 &amp;&amp; !flowDir-&gt;isNodata(i,j))
<a name="l00386"></a>00386                 {
<a name="l00387"></a>00387                     p=flowDir-&gt;getData(i,j,tempShort);
<a name="l00388"></a>00388                     inext=i+d1[p];
<a name="l00389"></a>00389                     jnext=j+d2[p];
<a name="l00390"></a>00390                     <span class="keywordflow">if</span>(!src-&gt;isNodata(inext,jnext) &amp;&amp; src-&gt;getData(inext,jnext,tempShort)&gt;0 &amp;&amp; !flowDir-&gt;isNodata(inext,jnext))
<a name="l00391"></a>00391                         contribs-&gt;setData(i,j,(<span class="keywordtype">short</span>)1);<span class="comment">//addData? What if it is a junction and has more floing into it?</span>
<a name="l00392"></a>00392                     <span class="keywordflow">else</span>
<a name="l00393"></a>00393                     {
<a name="l00394"></a>00394                         contribs-&gt;setData(i,j,(<span class="keywordtype">short</span>)0);
<a name="l00395"></a>00395                         t.x=i;
<a name="l00396"></a>00396                         t.y=j;
<a name="l00397"></a>00397                         que.push(t);
<a name="l00398"></a>00398                     }
<a name="l00399"></a>00399                 }
<a name="l00400"></a>00400             }
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402 <span class="comment">// while loop where each process empties its que, then shares border info, and repeats till everyone is done</span>
<a name="l00403"></a>00403         <span class="keywordtype">bool</span> finished=<span class="keyword">false</span>;
<a name="l00404"></a>00404         <span class="keywordtype">int</span> m;
<a name="l00405"></a>00405         <span class="comment">//int totalP=0;</span>
<a name="l00406"></a>00406         <span class="keywordflow">while</span>(!finished){
<a name="l00407"></a>00407             contribs-&gt;clearBorders();  
<a name="l00408"></a>00408             <span class="keywordflow">while</span>(!que.empty()){
<a name="l00409"></a>00409                 t=que.front(); 
<a name="l00410"></a>00410                 i=t.x; 
<a name="l00411"></a>00411                 j=t.y;
<a name="l00412"></a>00412                 que.pop();
<a name="l00413"></a>00413                 p=flowDir-&gt;getData(i,j,tempShort);
<a name="l00414"></a>00414                 <span class="keywordtype">float</span> llength=0.;
<a name="l00415"></a>00415                 inext=i+d1[p];
<a name="l00416"></a>00416                 jnext=j+d2[p];
<a name="l00417"></a>00417                 <span class="keywordflow">if</span>(!lengths-&gt;isNodata(inext,jnext))
<a name="l00418"></a>00418                 {
<a name="l00419"></a>00419                     llength += lengths-&gt;getData(inext,jnext,tempFloat);
<a name="l00420"></a>00420                     <span class="keywordflow">if</span>(p==1||p==5)llength=llength+dx;
<a name="l00421"></a>00421                     <span class="keywordflow">if</span>(p==3||p==7)llength=llength+dy;
<a name="l00422"></a>00422                     <span class="keywordflow">if</span>(p%2==0)llength=llength+diag;
<a name="l00423"></a>00423                 }
<a name="l00424"></a>00424                 lengths-&gt;setData(i,j,llength);
<a name="l00425"></a>00425                 <span class="comment">//totalP++;</span>
<a name="l00426"></a>00426                 <span class="comment">//  Find if neighbor points to me and reduce its dependency by 1</span>
<a name="l00427"></a>00427                 <span class="keywordflow">for</span>(m=1;m&lt;=8;++m){
<a name="l00428"></a>00428                     inext=i+d1[m];
<a name="l00429"></a>00429                     jnext=j+d2[m];
<a name="l00430"></a>00430                     <span class="keywordflow">if</span>(pointsToMe(i,j,inext,jnext,flowDir) &amp;&amp; !src-&gt;isNodata(inext,jnext)  &amp;&amp; src-&gt;getData(inext,jnext,tempShort)&gt;0)
<a name="l00431"></a>00431                     {
<a name="l00432"></a>00432                         contribs-&gt;addToData(inext,jnext,(<span class="keywordtype">short</span>)(-1));
<a name="l00433"></a>00433                         <span class="keywordflow">if</span>(contribs-&gt;isInPartition(inext,jnext) &amp;&amp; contribs-&gt;getData(inext,jnext,tempShort)==0)
<a name="l00434"></a>00434                         {
<a name="l00435"></a>00435                             t.x=inext;
<a name="l00436"></a>00436                             t.y=jnext;
<a name="l00437"></a>00437                             que.push(t);
<a name="l00438"></a>00438                         }
<a name="l00439"></a>00439                     }
<a name="l00440"></a>00440                 }
<a name="l00441"></a>00441             }
<a name="l00442"></a>00442             <span class="comment">//Pass information across partitions</span>
<a name="l00443"></a>00443 
<a name="l00444"></a>00444             contribs-&gt;addBorders();
<a name="l00445"></a>00445             lengths-&gt;share();
<a name="l00446"></a>00446 
<a name="l00447"></a>00447             <span class="comment">//If this created a cell with no contributing neighbors, put it on the queue</span>
<a name="l00448"></a>00448             <span class="keywordflow">for</span>(i=0; i&lt;nx; i++){
<a name="l00449"></a>00449                 <span class="keywordflow">if</span>(contribs-&gt;getData(i, -1, tempShort)!=0 &amp;&amp; contribs-&gt;getData(i, 0, tempShort)==0)
<a name="l00450"></a>00450                 {
<a name="l00451"></a>00451                     t.x = i;
<a name="l00452"></a>00452                     t.y = 0;
<a name="l00453"></a>00453                     que.push(t);
<a name="l00454"></a>00454                 }
<a name="l00455"></a>00455                 <span class="keywordflow">if</span>(contribs-&gt;getData(i, ny, tempShort)!=0 &amp;&amp; contribs-&gt;getData(i, ny-1, tempShort)==0)
<a name="l00456"></a>00456                 {
<a name="l00457"></a>00457                     t.x = i;
<a name="l00458"></a>00458                     t.y = ny-1;
<a name="l00459"></a>00459                     que.push(t); 
<a name="l00460"></a>00460                 }
<a name="l00461"></a>00461             }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463             <span class="comment">//Check if done</span>
<a name="l00464"></a>00464             finished = que.empty();
<a name="l00465"></a>00465             finished = contribs-&gt;ringTerm(finished);
<a name="l00466"></a>00466         }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468         <span class="comment">// Timer lengtht</span>
<a name="l00469"></a>00469         <span class="keywordtype">double</span> lengthct = MPI_Wtime();
<a name="l00470"></a>00470         <span class="keywordflow">if</span>(rank==0)
<a name="l00471"></a>00471         {
<a name="l00472"></a>00472             fprintf(stderr,<span class="stringliteral">&quot;Creating links\n&quot;</span>);
<a name="l00473"></a>00473             fflush(stderr);
<a name="l00474"></a>00474         }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476         <span class="keywordflow">if</span>(verbose)
<a name="l00477"></a>00477             cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Starting block to create links&quot;</span>  &lt;&lt; endl;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="comment">//  Now length partition is evaluated</span>
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment">//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span>
<a name="l00482"></a>00482 <span class="comment">//  Block to create links</span>
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="comment">//  Reinitialize contribs partition</span>
<a name="l00485"></a>00485         <span class="keyword">delete</span> contribs;
<a name="l00486"></a>00486         contribs = CreateNewPartition(SHORT_TYPE, TotalX, TotalY, dx, dy, MISSINGSHORT);
<a name="l00487"></a>00487         <span class="keywordtype">long</span> k = 0;
<a name="l00488"></a>00488 
<a name="l00489"></a>00489         <span class="keywordflow">for</span>(j=0;j&lt;ny;++j){
<a name="l00490"></a>00490             <span class="keywordflow">for</span>(i=0;i&lt;nx;++i){
<a name="l00491"></a>00491                 <span class="comment">// If I am on stream add 1 for each neighbor on stream that contribs to me</span>
<a name="l00492"></a>00492                 <span class="keywordflow">if</span>(!src-&gt;isNodata(i,j) &amp;&amp; src-&gt;getData(i,j,tempShort)&gt;0 &amp;&amp; !flowDir-&gt;isNodata(i,j))
<a name="l00493"></a>00493                 {
<a name="l00494"></a>00494                     <span class="keywordtype">short</span> tempc=0;  
<a name="l00495"></a>00495                     <span class="keywordflow">for</span>(k=1;k&lt;=8;k++)
<a name="l00496"></a>00496                     {
<a name="l00497"></a>00497                         inext=i+d1[k];
<a name="l00498"></a>00498                         jnext=j+d2[k];
<a name="l00499"></a>00499                         <span class="keywordflow">if</span>(pointsToMe(i,j,inext,jnext,flowDir) &amp;&amp; !src-&gt;isNodata(inext,jnext)  &amp;&amp; src-&gt;getData(inext,jnext,tempShort)&gt;0)
<a name="l00500"></a>00500                         {
<a name="l00501"></a>00501                             tempc=tempc+1;  
<a name="l00502"></a>00502                         }
<a name="l00503"></a>00503                     }
<a name="l00504"></a>00504                     contribs-&gt;setData(i,j,tempc);
<a name="l00505"></a>00505                     <span class="keywordflow">if</span>(tempc==0)
<a name="l00506"></a>00506                     {
<a name="l00507"></a>00507                         t.x=i;
<a name="l00508"></a>00508                         t.y=j;
<a name="l00509"></a>00509                         que.push(t);
<a name="l00510"></a>00510                     }
<a name="l00511"></a>00511                 }
<a name="l00512"></a>00512             }
<a name="l00513"></a>00513         }
<a name="l00514"></a>00514         <span class="comment">//  Indicate progress by about 10 dots per loop</span>
<a name="l00515"></a>00515         <span class="keywordtype">long</span> nque=que.size();
<a name="l00516"></a>00516         <span class="keywordtype">long</span> deltaque=nque/10+10;  <span class="comment">// + 10 to not give so many dots for small jobs</span>
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         <span class="keywordflow">if</span>(verbose)
<a name="l00520"></a>00520             cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot;   Starting main link creation loop&quot;</span>  &lt;&lt; endl;
<a name="l00521"></a>00521 <span class="comment">//XXXXXXXXXXXX  MAIN WHILE LOOP</span>
<a name="l00522"></a>00522 <span class="comment">// While loop where each process empties its que, then shares border info, and repeats till everyone is done</span>
<a name="l00523"></a>00523         finished=<span class="keyword">false</span>;
<a name="l00524"></a>00524         <span class="keywordflow">while</span>(!finished){
<a name="l00525"></a>00525             <span class="keywordtype">bool</span> linksToReceive=<span class="keyword">true</span>;
<a name="l00526"></a>00526             nque=que.size(); <span class="comment">//  used for indicating progress</span>
<a name="l00527"></a>00527             contribs-&gt;clearBorders();
<a name="l00528"></a>00528             <span class="keywordflow">while</span>(!que.empty()){
<a name="l00529"></a>00529                 t=que.front();
<a name="l00530"></a>00530                 i=t.x;
<a name="l00531"></a>00531                 j=t.y;
<a name="l00532"></a>00532                 que.pop();
<a name="l00533"></a>00533                 <span class="comment">//if(que.size() &lt; nque)</span>
<a name="l00534"></a>00534                 <span class="comment">//{</span>
<a name="l00535"></a>00535                 <span class="comment">//  nque=nque-deltaque;</span>
<a name="l00536"></a>00536                 <span class="comment">//  fprintf(stderr,&quot;.&quot;);</span>
<a name="l00537"></a>00537                 <span class="comment">//  fflush(stderr);</span>
<a name="l00538"></a>00538                 <span class="comment">//}</span>
<a name="l00539"></a>00539                 <span class="comment">// begin cell processing</span>
<a name="l00540"></a>00540                 <span class="keywordtype">short</span> nOrder[8];  <span class="comment">// neighborOrders</span>
<a name="l00541"></a>00541                 <span class="keywordtype">short</span> inneighbors[8];  <span class="comment">// inflowing neighbors</span>
<a name="l00542"></a>00542                 <span class="keywordtype">bool</span> junction; <span class="comment">// junction set to true/false in newOrder</span>
<a name="l00543"></a>00543                 <span class="keywordtype">long</span> Id;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545                 <span class="comment">//  Count number of grid cells on stream that point to me.  </span>
<a name="l00546"></a>00546                 <span class="comment">// (There will be no more than 8, usually only 0, 1,2 or 3.  The queue and </span>
<a name="l00547"></a>00547                 <span class="comment">// processing order ensures that the necessary results have already been </span>
<a name="l00548"></a>00548                 <span class="comment">//  evaluated for these.  In this case it should be a partially complete link </span>
<a name="l00549"></a>00549                 <span class="comment">//  object referenced by a value in a link object partition).  Number that flow </span>
<a name="l00550"></a>00550                 <span class="comment">//  to cell is k.  Record the order and direction to each. </span>
<a name="l00551"></a>00551                 k=0;
<a name="l00552"></a>00552                 <span class="keywordflow">for</span>(m=1;m&lt;=8;++m){
<a name="l00553"></a>00553                     inext=i+d1[m];
<a name="l00554"></a>00554                     jnext=j+d2[m];
<a name="l00555"></a>00555                     <span class="keywordflow">if</span>(pointsToMe(i,j,inext,jnext,flowDir) &amp;&amp; !src-&gt;isNodata(inext,jnext) &amp;&amp; src-&gt;getData(inext,jnext,tempShort)&gt;0 &amp;&amp; !idGrid-&gt;isNodata(inext,jnext)){
<a name="l00556"></a>00556                         inneighbors[k]=m;  
<a name="l00557"></a>00557                         <span class="comment">//  stream orders are stored in lengths grid to save memory</span>
<a name="l00558"></a>00558                         nOrder[k]= (short)lengths-&gt;getData(inext,jnext,tempFloat); 
<a name="l00559"></a>00559                         k=k+1;  <span class="comment">// count inflows</span>
<a name="l00560"></a>00560                     }
<a name="l00561"></a>00561                 }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563                 <span class="comment">// Determine downslope neighbor</span>
<a name="l00564"></a>00564                 <span class="keywordtype">long</span> nextx,nexty;
<a name="l00565"></a>00565                 p=flowDir-&gt;getData(i,j,tempShort);
<a name="l00566"></a>00566                 nextx=t.x+d1[p];
<a name="l00567"></a>00567                 nexty=t.y+d2[p];
<a name="l00568"></a>00568 
<a name="l00569"></a>00569                 <span class="comment">// Determine if mandatory junction indicated by a value in idGrid</span>
<a name="l00570"></a>00570                 <span class="keywordtype">bool</span> mandatoryJunction=<span class="keyword">false</span>;
<a name="l00571"></a>00571                 <span class="keywordtype">long</span> shapeID;
<a name="l00572"></a>00572                 <span class="keywordflow">if</span>(!idGrid-&gt;isNodata(i,j))
<a name="l00573"></a>00573                 {
<a name="l00574"></a>00574                     mandatoryJunction=<span class="keyword">true</span>;
<a name="l00575"></a>00575                     shapeID=idGrid-&gt;getData(i,j,shapeID);
<a name="l00576"></a>00576                 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578                 <span class="comment">//- determine if terminal link by if downslope neighbor is out of domain</span>
<a name="l00579"></a>00579                 <span class="keywordtype">bool</span> terminal = <span class="keyword">false</span>;
<a name="l00580"></a>00580                 <span class="keywordflow">if</span>(!src-&gt;hasAccess(nextx,nexty)  || src-&gt;isNodata(nextx,nexty) 
<a name="l00581"></a>00581                     || (src-&gt;getData(nextx,nexty,tempShort) != 1))
<a name="l00582"></a>00582                     terminal = <span class="keyword">true</span>;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584                 <span class="comment">//  instantiate point</span>
<a name="l00585"></a>00585                 point* addPoint;
<a name="l00586"></a>00586                 addPoint = initPoint(elev,areaD8,lengths,i,j);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588                 <span class="comment">//  Case for start of flow path</span>
<a name="l00589"></a>00589                 <span class="keywordflow">if</span>(k==0){
<a name="l00590"></a>00590                     <span class="comment">//  This is the start of a stream - instantiate new link</span>
<a name="l00591"></a>00591                     streamlink *thisLink;
<a name="l00592"></a>00592                     thisLink = createLink(-1, -1, -1, addPoint); <span class="comment">//,1); //, dx,dy);</span>
<a name="l00593"></a>00593                     <span class="keywordtype">long</span> u1= thisLink-&gt;Id;
<a name="l00594"></a>00594                     idGrid-&gt;setData(i,j, u1);
<a name="l00595"></a>00595                     wsGrid-&gt;setData(i,j, u1);
<a name="l00596"></a>00596                     lengths-&gt;setData(i,j,(<span class="keywordtype">float</span>)thisLink-&gt;order);
<a name="l00597"></a>00597 
<a name="l00598"></a>00598                     <span class="comment">//  Handle mandatory junction</span>
<a name="l00599"></a>00599                     <span class="keywordflow">if</span>(mandatoryJunction){
<a name="l00600"></a>00600                         appendPoint(u1, addPoint);
<a name="l00601"></a>00601                         thisLink-&gt;shapeId = shapeID;
<a name="l00602"></a>00602                         <span class="keywordflow">if</span>(!terminal){
<a name="l00603"></a>00603                             streamlink *newLink;
<a name="l00604"></a>00604                             newLink = createLink(u1,-1,-1, addPoint); <span class="comment">//, 1); //, dx,dy);</span>
<a name="l00605"></a>00605                             newLink-&gt;order =  1;    
<a name="l00606"></a>00606                             setDownLinkId(u1,newLink-&gt;Id);      
<a name="l00607"></a>00607                             newLink-&gt;magnitude = 1;
<a name="l00608"></a>00608                             terminateLink(u1);
<a name="l00609"></a>00609                             idGrid-&gt;setData(i,j,newLink-&gt;Id);
<a name="l00610"></a>00610                             <span class="comment">//  Here idGrid and wsGrid intentionally out of sync</span>
<a name="l00611"></a>00611                             <span class="comment">//  idGrid to be used to retrieve upstream link for next cell down</span>
<a name="l00612"></a>00612                             <span class="comment">//  wsGrid used to hold the id for delineation of watersheds which </span>
<a name="l00613"></a>00613                             <span class="comment">//  is the link that ends at this point</span>
<a name="l00614"></a>00614                         }
<a name="l00615"></a>00615                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(terminal){  <span class="comment">// handle terminal that is not mandatory junction</span>
<a name="l00616"></a>00616                         appendPoint(u1, addPoint);
<a name="l00617"></a>00617                     }
<a name="l00618"></a>00618                 }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620                 <span class="comment">//  Case for ongoing flow path with single inflow</span>
<a name="l00621"></a>00621                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(k==1){
<a name="l00622"></a>00622                     <span class="keywordtype">long</span> u1=idGrid-&gt;getData(i+d1[inneighbors[0]],j+d2[inneighbors[0]],tempLong);
<a name="l00623"></a>00623                     appendPoint(u1, addPoint);
<a name="l00624"></a>00624                     streamlink *thisLink;
<a name="l00625"></a>00625                     <span class="comment">//TODO DGT Thinks</span>
<a name="l00626"></a>00626                     <span class="comment">// thisLink=u1;  for efficiency</span>
<a name="l00627"></a>00627                     thisLink=FindLink(u1);
<a name="l00628"></a>00628                     <span class="comment">//cout &lt;&lt; &quot;append done&quot;  &lt;&lt; endl;</span>
<a name="l00629"></a>00629                     idGrid-&gt;setData(i,j,u1);
<a name="l00630"></a>00630                     wsGrid-&gt;setData(i,j,u1);
<a name="l00631"></a>00631                     lengths-&gt;setData(i,j,(<span class="keywordtype">float</span>)nOrder[0]);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633                     <span class="comment">//  Handle mandatory junction case</span>
<a name="l00634"></a>00634                     <span class="keywordflow">if</span>(mandatoryJunction){
<a name="l00635"></a>00635                         thisLink-&gt;shapeId = shapeID;
<a name="l00636"></a>00636                         <span class="keywordflow">if</span>(!terminal){
<a name="l00637"></a>00637                             streamlink *newLink;
<a name="l00638"></a>00638                             newLink = createLink(u1,-1,-1, addPoint); <span class="comment">//, 1); //, dx,dy);</span>
<a name="l00639"></a>00639                             newLink-&gt;order =  thisLink-&gt;order;  
<a name="l00640"></a>00640                             setDownLinkId(u1,newLink-&gt;Id);      
<a name="l00641"></a>00641                             newLink-&gt;magnitude = thisLink-&gt;magnitude;
<a name="l00642"></a>00642                             terminateLink(u1);
<a name="l00643"></a>00643                             idGrid-&gt;setData(i,j,newLink-&gt;Id);
<a name="l00644"></a>00644                             <span class="comment">//  TODO Here need to assign WSNO = -1</span>
<a name="l00645"></a>00645                         }
<a name="l00646"></a>00646                     }
<a name="l00647"></a>00647                 }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649                 <span class="comment">// Case for multiple inflows</span>
<a name="l00650"></a>00650                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(k&gt;1){
<a name="l00651"></a>00651                     <span class="comment">//  rank incoming flow paths from highest to lowest order and process in this order</span>
<a name="l00652"></a>00652                     <span class="comment">//cout &lt;&lt; &quot;k&gt;1 junction: &quot;  &lt;&lt; k &lt;&lt; endl;</span>
<a name="l00653"></a>00653                     <span class="comment">//Dans Code to sort the two largest to the bottom of the list</span>
<a name="l00654"></a>00654                     <span class="keywordtype">short</span> temp;
<a name="l00655"></a>00655                     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> a=0;a&lt;2;++a){
<a name="l00656"></a>00656                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> b=0;b&lt;k-1;++b){
<a name="l00657"></a>00657                             <span class="keywordflow">if</span>(nOrder[b]&gt;nOrder[b+1]){
<a name="l00658"></a>00658                                 temp=nOrder[b];
<a name="l00659"></a>00659                                 nOrder[b]=nOrder[b+1];
<a name="l00660"></a>00660                                 nOrder[b+1]=temp;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662                                 temp = inneighbors[b];
<a name="l00663"></a>00663                                 inneighbors[b] = inneighbors[b+1];
<a name="l00664"></a>00664                                 inneighbors[b+1] = temp;<span class="comment">//keep track of where they came from. </span>
<a name="l00665"></a>00665                             }
<a name="l00666"></a>00666                         }
<a name="l00667"></a>00667                     }   
<a name="l00668"></a>00668                     <span class="comment">// Determine order out</span>
<a name="l00669"></a>00669                     <span class="keywordtype">short</span> oOut;<span class="comment">//if the last two have the same order, there is a junction, so bump the order</span>
<a name="l00670"></a>00670                     <span class="keywordflow">if</span>(nOrder[k-2]==nOrder[k-1]){
<a name="l00671"></a>00671                             <span class="comment">//junction=true;</span>
<a name="l00672"></a>00672                         oOut=nOrder[k-1]+1;
<a name="l00673"></a>00673                     }<span class="keywordflow">else</span>{
<a name="l00674"></a>00674                         oOut=nOrder[k-1];
<a name="l00675"></a>00675                     }
<a name="l00676"></a>00676                     <span class="keywordtype">long</span> u1, u2;
<a name="l00677"></a>00677                     u1 = idGrid-&gt;getData(i+d1[inneighbors[k-1]],j+d2[inneighbors[k-1]],tempLong);
<a name="l00678"></a>00678                     u2 = idGrid-&gt;getData(i+d1[inneighbors[k-2]],j+d2[inneighbors[k-2]],tempLong);
<a name="l00679"></a>00679                     appendPoint(u1, addPoint);
<a name="l00680"></a>00680                     appendPoint(u2, addPoint);
<a name="l00681"></a>00681                     streamlink *newLink;
<a name="l00682"></a>00682                     newLink = createLink(u1,u2,-1,addPoint); <span class="comment">//,1); //,dx,dy);</span>
<a name="l00683"></a>00683                     newLink-&gt;order = oOut;
<a name="l00684"></a>00684                     setDownLinkId(u1,newLink-&gt;Id);
<a name="l00685"></a>00685                     setDownLinkId(u2,newLink-&gt;Id);
<a name="l00686"></a>00686                     newLink-&gt;magnitude = getMagnitude(u1) + getMagnitude(u2);
<a name="l00687"></a>00687                     
<a name="l00688"></a>00688                     <span class="comment">//  TODO add WSNO = -1</span>
<a name="l00689"></a>00689 
<a name="l00690"></a>00690                     terminateLink(u1);
<a name="l00691"></a>00691                     terminateLink(u2);
<a name="l00692"></a>00692 
<a name="l00693"></a>00693                     <span class="comment">//  Handle remaining incoming flow paths</span>
<a name="l00694"></a>00694                     <span class="keywordflow">for</span>(m=2; m&lt;k; m++)   <span class="comment">//  Loop is only entered if k&gt;=3</span>
<a name="l00695"></a>00695                     {
<a name="l00696"></a>00696                         u1 = newLink-&gt;Id;
<a name="l00697"></a>00697                         u2 = idGrid-&gt;getData(i+d1[inneighbors[k-m-1]],j+d2[inneighbors[k-m-1]],tempLong);
<a name="l00698"></a>00698 
<a name="l00699"></a>00699                         appendPoint(u1, addPoint);
<a name="l00700"></a>00700                         appendPoint(u2, addPoint);
<a name="l00701"></a>00701 
<a name="l00702"></a>00702                         <span class="comment">// create a new link</span>
<a name="l00703"></a>00703                         newLink = createLink(u1,u2,-1,addPoint); <span class="comment">//,1);  //,dx,dy);</span>
<a name="l00704"></a>00704                         <span class="comment">//  set order of new link as order out</span>
<a name="l00705"></a>00705                         newLink-&gt;order = oOut;
<a name="l00706"></a>00706                         <span class="comment">//  set u1 to previously created link</span>
<a name="l00707"></a>00707                         setDownLinkId(u1, newLink-&gt;Id);
<a name="l00708"></a>00708                         setDownLinkId(u2, newLink-&gt;Id);
<a name="l00709"></a>00709                         newLink-&gt;magnitude = getMagnitude(u1) + getMagnitude(u2);
<a name="l00710"></a>00710                         
<a name="l00711"></a>00711                         <span class="comment">//  TODO add WSNO = -1</span>
<a name="l00712"></a>00712 
<a name="l00713"></a>00713                         terminateLink(u1);
<a name="l00714"></a>00714                         terminateLink(u2);
<a name="l00715"></a>00715                     }
<a name="l00716"></a>00716                     idGrid-&gt;setData(i,j,newLink-&gt;Id);<span class="comment">// Set the idGrid to the new link ID?</span>
<a name="l00717"></a>00717                     wsGrid-&gt;setData(i,j,newLink-&gt;Id);
<a name="l00718"></a>00718                     lengths-&gt;setData(i,j,(<span class="keywordtype">float</span>)oOut);
<a name="l00719"></a>00719                     <span class="keywordflow">if</span>(mandatoryJunction){
<a name="l00720"></a>00720                         <span class="comment">// create a zero length link to the mandatory junction</span>
<a name="l00721"></a>00721                         u1 = newLink-&gt;Id;
<a name="l00722"></a>00722                         appendPoint(u1, addPoint);
<a name="l00723"></a>00723                         newLink-&gt;shapeId=shapeID;
<a name="l00724"></a>00724 
<a name="l00725"></a>00725                         <span class="comment">//  TODO assign u1 to WSNO</span>
<a name="l00726"></a>00726                         <span class="keywordflow">if</span>(!terminal){
<a name="l00727"></a>00727                             newLink = createLink(u1,-1,-1,addPoint); <span class="comment">//,1); //,dx,dy);</span>
<a name="l00728"></a>00728                             <span class="comment">//  set order of new link as order out</span>
<a name="l00729"></a>00729                             newLink-&gt;order = oOut;
<a name="l00730"></a>00730                             <span class="comment">//  set u1 to previously created link</span>
<a name="l00731"></a>00731                             setDownLinkId(u1, newLink-&gt;Id);
<a name="l00732"></a>00732                             newLink-&gt;magnitude = getMagnitude(u1);
<a name="l00733"></a>00733                             idGrid-&gt;setData(i,j,newLink-&gt;Id);<span class="comment">// Set the idGrid to the new link ID?</span>
<a name="l00734"></a>00734                             <span class="comment">//  TODO assign -1 to WNSO</span>
<a name="l00735"></a>00735                         }
<a name="l00736"></a>00736                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(terminal){
<a name="l00737"></a>00737                         u1 = newLink-&gt;Id;
<a name="l00738"></a>00738                         appendPoint(u1, addPoint);
<a name="l00739"></a>00739                         <span class="comment">//  TODO assign u1 to WSNO</span>
<a name="l00740"></a>00740                     }
<a name="l00741"></a>00741                 }
<a name="l00742"></a>00742                 <span class="comment">//Check if down neighbor needs to be added to que</span>
<a name="l00743"></a>00743                 contribs-&gt;addToData(nextx,nexty,(<span class="keywordtype">short</span>)-1);
<a name="l00744"></a>00744                 <span class="keywordflow">if</span>(contribs-&gt;isInPartition(nextx,nexty))
<a name="l00745"></a>00745                 {
<a name="l00746"></a>00746                     <span class="keywordflow">if</span>(contribs-&gt;getData(nextx, nexty, tempShort) == 0 ){
<a name="l00747"></a>00747                         t.x=nextx;
<a name="l00748"></a>00748                         t.y=nexty;
<a name="l00749"></a>00749                         que.push(t);
<a name="l00750"></a>00750                     }
<a name="l00751"></a>00751                 }
<a name="l00752"></a>00752                 <span class="comment">//  IF link is to be sent</span>
<a name="l00753"></a>00753                 <span class="comment">//     ID which process to go to (rank - 1 or rank + 1)</span>
<a name="l00754"></a>00754                 <span class="comment">//     Add id to a list for that process</span>
<a name="l00755"></a>00755                 <span class="comment">//     count number for that process</span>
<a name="l00756"></a>00756                 <span class="keywordflow">else</span> 
<a name="l00757"></a>00757                 {
<a name="l00758"></a>00758                     <span class="comment">//  Package up the link that either began or is in process at cell i,j and send to downstream partition</span>
<a name="l00759"></a>00759                     <span class="comment">//  Link has to be sent</span>
<a name="l00760"></a>00760                     <span class="keywordflow">if</span>(nexty&lt;0 &amp;&amp; rank&gt;0)  <span class="comment">// up</span>
<a name="l00761"></a>00761                     {
<a name="l00762"></a>00762                         temp.id = idGrid-&gt;getData(i,j,tempLong);
<a name="l00763"></a>00763                         temp.dest = rank-1;
<a name="l00764"></a>00764                         linkQ.push(temp);
<a name="l00765"></a>00765                         Sup++;
<a name="l00766"></a>00766                     }
<a name="l00767"></a>00767                     <span class="keywordflow">if</span>(nexty&gt;=ny &amp;&amp; rank &lt; size-1)
<a name="l00768"></a>00768                     {
<a name="l00769"></a>00769                         temp.id = idGrid-&gt;getData(i,j,tempLong);
<a name="l00770"></a>00770                         temp.dest = rank+1;
<a name="l00771"></a>00771                         linkQ.push(temp);
<a name="l00772"></a>00772                         Sdown++;
<a name="l00773"></a>00773                     }
<a name="l00774"></a>00774                 }
<a name="l00775"></a>00775             }
<a name="l00776"></a>00776             <span class="keywordflow">if</span>(verbose)
<a name="l00777"></a>00777             {
<a name="l00778"></a>00778                 cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; End link creation pass - about to share&quot;</span> &lt;&lt; endl;
<a name="l00779"></a>00779                 MPI_Status stat;
<a name="l00780"></a>00780                 <span class="keywordtype">int</span> messageFlag = <span class="keyword">false</span>;
<a name="l00781"></a>00781                 MPI_Iprobe(MPI_ANY_SOURCE, MPI_ANY_TAG, MCW, &amp;messageFlag, &amp;stat);
<a name="l00782"></a>00782                 <span class="keywordflow">if</span>(messageFlag == <span class="keyword">true</span>){
<a name="l00783"></a>00783                         cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot;: I have a message waiting before I try to pass links!!!&quot;</span> &lt;&lt; stat.MPI_TAG &lt;&lt; endl;
<a name="l00784"></a>00784                         MPI_Abort(MCW,4);
<a name="l00785"></a>00785                 }
<a name="l00786"></a>00786                 MPI_Barrier(MCW);
<a name="l00787"></a>00787             }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 <span class="comment">//  Block to swap links</span>
<a name="l00790"></a>00790             <span class="keywordflow">if</span>(size &gt; 1)
<a name="l00791"></a>00791             {
<a name="l00792"></a>00792                 <span class="keywordtype">long</span> numRecv;
<a name="l00793"></a>00793                 MPI_Status stat;
<a name="l00794"></a>00794                 <span class="keywordflow">if</span>(rank &lt; size-1){<span class="comment">//only send down</span>
<a name="l00795"></a>00795                     MPI_Send(&amp;Sdown,1,MPI_LONG,rank+1,0,MCW);<span class="comment">//send message saying done</span>
<a name="l00796"></a>00796                     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j =0; j&lt;Sdown; j++){
<a name="l00797"></a>00797                         temp.id = linkQ.front().id;
<a name="l00798"></a>00798                         temp.dest = linkQ.front().dest;
<a name="l00799"></a>00799                         linkQ.pop();<span class="comment">//all an the q should go to the same dest.</span>
<a name="l00800"></a>00800                         <span class="keywordflow">while</span>(temp.dest != rank+1){
<a name="l00801"></a>00801                             linkQ.push(temp);
<a name="l00802"></a>00802                             temp.id = linkQ.front().id;
<a name="l00803"></a>00803                             temp.dest = linkQ.front().dest;
<a name="l00804"></a>00804                             linkQ.pop();<span class="comment">//all an the q should go to the same dest.</span>
<a name="l00805"></a>00805                         }
<a name="l00806"></a>00806                         sendLink(temp.id,temp.dest);
<a name="l00807"></a>00807                     }
<a name="l00808"></a>00808                 }
<a name="l00809"></a>00809                 <span class="keywordflow">if</span>(rank &gt;0)
<a name="l00810"></a>00810                 {
<a name="l00811"></a>00811                     MPI_Recv(&amp;numRecv,1,MPI_LONG,rank-1,0,MCW,&amp;stat);
<a name="l00812"></a>00812                     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j =0 ;j&lt;numRecv;j++){
<a name="l00813"></a>00813                         recvLink(rank-1);<span class="comment">//recv from up.</span>
<a name="l00814"></a>00814                     }
<a name="l00815"></a>00815                 }
<a name="l00816"></a>00816                 <span class="keywordflow">if</span>(rank &gt; 0)
<a name="l00817"></a>00817                 {
<a name="l00818"></a>00818                     MPI_Send(&amp;Sup,1,MPI_LONG,rank-1,0,MCW);<span class="comment">//send message saying up</span>
<a name="l00819"></a>00819                     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j =0; j&lt;Sup; j++){
<a name="l00820"></a>00820                         temp.id = linkQ.front().id;
<a name="l00821"></a>00821                         temp.dest = linkQ.front().dest;
<a name="l00822"></a>00822                         linkQ.pop();<span class="comment">//all an the q should go to the same dest.</span>
<a name="l00823"></a>00823                         sendLink(temp.id,temp.dest);
<a name="l00824"></a>00824                     }
<a name="l00825"></a>00825                 }
<a name="l00826"></a>00826                 <span class="keywordflow">if</span>(rank &lt; size -1)
<a name="l00827"></a>00827                 {
<a name="l00828"></a>00828                     MPI_Recv(&amp;numRecv,1,MPI_LONG,rank+1,0,MCW,&amp;stat);
<a name="l00829"></a>00829                     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0;j &lt; numRecv; j++){
<a name="l00830"></a>00830                         recvLink(rank+1);<span class="comment">//recv from below.</span>
<a name="l00831"></a>00831                     }
<a name="l00832"></a>00832                 }
<a name="l00833"></a>00833 
<a name="l00834"></a>00834                 <span class="comment">//MPI_Barrier(MCW);</span>
<a name="l00835"></a>00835                 Sup = 0;
<a name="l00836"></a>00836                 Sdown = 0;
<a name="l00837"></a>00837                 
<a name="l00838"></a>00838                 <span class="comment">//MPI_Status stat;</span>
<a name="l00839"></a>00839     <span class="comment">//                  int messageFlag = false;</span>
<a name="l00840"></a>00840     <span class="comment">//                  MPI_Iprobe(MPI_ANY_SOURCE, MPI_ANY_TAG, MCW, &amp;messageFlag, &amp;stat);</span>
<a name="l00841"></a>00841     <span class="comment">//                      if(messageFlag == true){</span>
<a name="l00842"></a>00842     <span class="comment">//                          cout &lt;&lt; rank &lt;&lt; &quot;: I have failed to received a message!!!&quot; &lt;&lt; stat.MPI_TAG &lt;&lt; endl;</span>
<a name="l00843"></a>00843     <span class="comment">//                          MPI_Abort(MCW,3);</span>
<a name="l00844"></a>00844     <span class="comment">//                  }</span>
<a name="l00845"></a>00845                 <span class="comment">//MPI_Barrier(MCW);</span>
<a name="l00846"></a>00846                 idGrid-&gt;share();
<a name="l00847"></a>00847                 wsGrid-&gt;share();
<a name="l00848"></a>00848                 lengths-&gt;share();
<a name="l00849"></a>00849                 contribs-&gt;addBorders();
<a name="l00850"></a>00850 
<a name="l00851"></a>00851                 <span class="keywordflow">for</span>(i=0; i&lt;nx; i++){<span class="comment">//todo fix this to add passed to queue</span>
<a name="l00852"></a>00852                     <span class="keywordflow">if</span>(contribs-&gt;getData(i, 0, tempShort) == 0 &amp;&amp; contribs-&gt;getData(i,-1,tempShort)!=0) <span class="comment">//may receive flow from more than 1</span>
<a name="l00853"></a>00853                     {
<a name="l00854"></a>00854                         t.x = i;
<a name="l00855"></a>00855                         t.y = 0;
<a name="l00856"></a>00856                         que.push(t);
<a name="l00857"></a>00857                     }
<a name="l00858"></a>00858                     <span class="keywordflow">if</span>(contribs-&gt;getData(i, ny-1, tempShort) == 0 &amp;&amp; contribs-&gt;getData(i,ny,tempShort)!=0)<span class="comment">//only looks at one direction of flow, out of a partition &amp;&amp; idGrid-&gt;isNodata(i,ny-1) &amp;&amp; src-&gt;getData(i,ny-1,tempShort)==1</span>
<a name="l00859"></a>00859                     {
<a name="l00860"></a>00860                         t.x = i;
<a name="l00861"></a>00861                         t.y = ny-1;
<a name="l00862"></a>00862                         que.push(t); 
<a name="l00863"></a>00863                     }
<a name="l00864"></a>00864                 }
<a name="l00865"></a>00865                 finished = que.empty();
<a name="l00866"></a>00866                 <span class="comment">//MPI_Barrier(MCW);</span>
<a name="l00867"></a>00867                 <span class="keywordtype">int</span> total = 0;
<a name="l00868"></a>00868                 <span class="keywordtype">int</span> AllSum = 0;
<a name="l00869"></a>00869                 <span class="keywordflow">if</span>(!finished)
<a name="l00870"></a>00870                     total = que.size();
<a name="l00871"></a>00871                 MPI_Allreduce(&amp;total,&amp;AllSum,1,MPI_INT,MPI_SUM,MCW);
<a name="l00872"></a>00872                 <span class="keywordflow">if</span>(AllSum == 0)
<a name="l00873"></a>00873                     finished = <span class="keyword">true</span>;
<a name="l00874"></a>00874                 <span class="keywordflow">else</span>
<a name="l00875"></a>00875                     finished = <span class="keyword">false</span>;
<a name="l00876"></a>00876                 <span class="keywordflow">if</span>(verbose)
<a name="l00877"></a>00877                 {
<a name="l00878"></a>00878                     cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Remaining in partition queue: &quot;</span> &lt;&lt; total &lt;&lt; endl;
<a name="l00879"></a>00879                     cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Remaining total: &quot;</span> &lt;&lt; AllSum &lt;&lt; endl;
<a name="l00880"></a>00880                 }
<a name="l00881"></a>00881             }
<a name="l00882"></a>00882             <span class="keywordflow">else</span>
<a name="l00883"></a>00883                 finished=<span class="keyword">true</span>;  <span class="comment">// For size == 1 no partition loop</span>
<a name="l00884"></a>00884         }   
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 <span class="comment">//  Now all links have been created</span>
<a name="l00887"></a>00887         <span class="comment">// Timer</span>
<a name="l00888"></a>00888         <span class="keywordtype">double</span> linkct = MPI_Wtime();
<a name="l00889"></a>00889         <span class="comment">//if(rank == 0)</span>
<a name="l00890"></a>00890         <span class="comment">//{</span>
<a name="l00891"></a>00891         <span class="comment">//  fprintf(stderr,&quot;\nLinks have been created, starting to write links\n&quot;);</span>
<a name="l00892"></a>00892         <span class="comment">//  fflush(stderr);</span>
<a name="l00893"></a>00893         <span class="comment">//}</span>
<a name="l00894"></a>00894 <span class="comment">//  XXXXXXXXX</span>
<a name="l00895"></a>00895 <span class="comment">//  Block to write link data</span>
<a name="l00896"></a>00896 
<a name="l00897"></a>00897         <span class="keywordflow">if</span>(verbose)
<a name="l00898"></a>00898         {
<a name="l00899"></a>00899             cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Starting to write links&quot;</span>  &lt;&lt; endl;
<a name="l00900"></a>00900             MPI_Status stat;
<a name="l00901"></a>00901             <span class="keywordtype">int</span> messageFlag = <span class="keyword">false</span>;
<a name="l00902"></a>00902             MPI_Iprobe(MPI_ANY_SOURCE, MPI_ANY_TAG, MCW, &amp;messageFlag, &amp;stat);
<a name="l00903"></a>00903             <span class="keywordflow">if</span>(messageFlag == <span class="keyword">true</span>){
<a name="l00904"></a>00904                     cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot;: I have failed to received a message!!!&quot;</span> &lt;&lt; endl;
<a name="l00905"></a>00905                     MPI_Abort(MCW,2);
<a name="l00906"></a>00906             }
<a name="l00907"></a>00907             MPI_Barrier(MCW);
<a name="l00908"></a>00908         }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910         <span class="keywordtype">long</span> myNumLinks;
<a name="l00911"></a>00911         <span class="keywordtype">long</span> myNumPoints;
<a name="l00912"></a>00912         <span class="keywordtype">long</span> totalNumLinks;
<a name="l00913"></a>00913         <span class="keywordtype">long</span> totalNumPoints;
<a name="l00914"></a>00914         <span class="keywordtype">long</span> relativePointStart;<span class="comment">//if 9 then line 9 is first to be filled by me</span>
<a name="l00915"></a>00915 
<a name="l00916"></a>00916         <span class="keywordtype">double</span> **PointXY;
<a name="l00917"></a>00917         <span class="keywordtype">float</span> **PointElevArea;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         <span class="keywordtype">long</span> **LinkIdU1U2DMagShapeidCoords;
<a name="l00920"></a>00920         <span class="keywordtype">double</span> **LinkElevUElevDLength;
<a name="l00921"></a>00921         <span class="keywordtype">long</span> *buf;
<a name="l00922"></a>00922         <span class="keywordtype">long</span> *ptr;
<a name="l00923"></a>00923         <span class="keywordtype">int</span> place;
<a name="l00924"></a>00924         <span class="keywordtype">int</span> bsize = <span class="keyword">sizeof</span>(long)+ MPI_BSEND_OVERHEAD;  
<a name="l00925"></a>00925         buf = <span class="keyword">new</span> <span class="keywordtype">long</span>[bsize];
<a name="l00926"></a>00926         getNumLinksAndPoints(myNumLinks,myNumPoints);
<a name="l00927"></a>00927         <span class="comment">//MPI_Barrier(MCW);</span>
<a name="l00928"></a>00928 
<a name="l00929"></a>00929         i = 0;
<a name="l00930"></a>00930         <span class="keywordflow">if</span>(myNumLinks &gt; 0){
<a name="l00931"></a>00931             LinkIdU1U2DMagShapeidCoords = <span class="keyword">new</span> <span class="keywordtype">long</span>*[myNumLinks];
<a name="l00932"></a>00932             <span class="keywordflow">for</span>(i=0;i&lt;myNumLinks;i++)
<a name="l00933"></a>00933                 LinkIdU1U2DMagShapeidCoords[i] = <span class="keyword">new</span> <span class="keywordtype">long</span>[9];
<a name="l00934"></a>00934 
<a name="l00935"></a>00935             LinkElevUElevDLength = <span class="keyword">new</span> <span class="keywordtype">double</span>*[myNumLinks];
<a name="l00936"></a>00936             <span class="keywordflow">for</span>(i = 0;i&lt;myNumLinks;i++) 
<a name="l00937"></a>00937                 LinkElevUElevDLength[i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[3];
<a name="l00938"></a>00938 
<a name="l00939"></a>00939             <span class="keywordflow">if</span>(myNumPoints&gt;0)
<a name="l00940"></a>00940             {
<a name="l00941"></a>00941                 PointXY = <span class="keyword">new</span> <span class="keywordtype">double</span>*[myNumPoints];
<a name="l00942"></a>00942                 <span class="keywordflow">for</span>(i=0;i&lt;myNumPoints;i++)
<a name="l00943"></a>00943                     PointXY[i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[2];
<a name="l00944"></a>00944 
<a name="l00945"></a>00945                 PointElevArea = <span class="keyword">new</span> <span class="keywordtype">float</span>*[myNumPoints];
<a name="l00946"></a>00946                 <span class="keywordflow">for</span>(i=0;i&lt;myNumPoints;i++)
<a name="l00947"></a>00947                     PointElevArea[i] = <span class="keyword">new</span> <span class="keywordtype">float</span>[3];
<a name="l00948"></a>00948 
<a name="l00949"></a>00949                 setLinkInfo(LinkIdU1U2DMagShapeidCoords,LinkElevUElevDLength,PointXY,PointElevArea,elev,&amp;elevIO);
<a name="l00950"></a>00950             }
<a name="l00951"></a>00951         }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         <span class="keywordtype">int</span> ibuf;
<a name="l00954"></a>00954         <span class="keywordtype">int</span> procNumPoints;
<a name="l00955"></a>00955         <span class="keywordtype">int</span> totalPoints = 0;
<a name="l00956"></a>00956         <span class="keywordtype">float</span> pbuf[3];
<a name="l00957"></a>00957         <span class="keywordtype">double</span> pbuf1[2];
<a name="l00958"></a>00958         MPI_Status mystatus;
<a name="l00959"></a>00959         
<a name="l00960"></a>00960         <span class="keywordtype">int</span> numPointsPrinted =0;
<a name="l00961"></a>00961         <span class="keywordtype">int</span> procNumLinks = 0;
<a name="l00962"></a>00962         <span class="keywordtype">long</span> treeBuf[9];
<a name="l00963"></a>00963 
<a name="l00964"></a>00964         <span class="keywordtype">int</span> ilink, ipoint;
<a name="l00965"></a>00965         <span class="keywordflow">if</span>(rank==0){<span class="comment">//open output point file</span>
<a name="l00966"></a>00966             FILE *fTreeOut;
<a name="l00967"></a>00967             fTreeOut = fopen(treefile,<span class="stringliteral">&quot;w&quot;</span>);<span class="comment">// process 0 writes all of its stuff</span>
<a name="l00968"></a>00968             FILE *fout;
<a name="l00969"></a>00969             fout = fopen(coordfile,<span class="stringliteral">&quot;w&quot;</span>);
<a name="l00970"></a>00970 
<a name="l00971"></a>00971             <span class="comment">//  Open shapefile</span>
<a name="l00972"></a>00972             createStreamNetShapefile(streamnetshp);
<a name="l00973"></a>00973 
<a name="l00974"></a>00974             <span class="keywordtype">long</span> ndots=100/size+4;  <span class="comment">// number of dots to print per process</span>
<a name="l00975"></a>00975             <span class="keywordtype">long</span> nextdot=0;
<a name="l00976"></a>00976             <span class="keywordtype">long</span> dotinc=myNumLinks/ndots;
<a name="l00977"></a>00977 
<a name="l00978"></a>00978             <span class="keywordflow">for</span>(ilink=0;ilink&lt;myNumLinks;ilink++){<span class="comment">//only once per link</span>
<a name="l00979"></a>00979                 fprintf(fTreeOut,<span class="stringliteral">&quot;\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n&quot;</span>,LinkIdU1U2DMagShapeidCoords[ilink][0],LinkIdU1U2DMagShapeidCoords[ilink][1],LinkIdU1U2DMagShapeidCoords[ilink][2],LinkIdU1U2DMagShapeidCoords[ilink][3],LinkIdU1U2DMagShapeidCoords[ilink][4],LinkIdU1U2DMagShapeidCoords[ilink][5],LinkIdU1U2DMagShapeidCoords[ilink][6],LinkIdU1U2DMagShapeidCoords[ilink][7],LinkIdU1U2DMagShapeidCoords[ilink][8]);
<a name="l00980"></a>00980                 <span class="comment">//fflush(fTreeOut);</span>
<a name="l00981"></a>00981                 <span class="keywordtype">long</span> i1=LinkIdU1U2DMagShapeidCoords[ilink][1];
<a name="l00982"></a>00982                 <span class="keywordtype">long</span> i2=LinkIdU1U2DMagShapeidCoords[ilink][2];
<a name="l00983"></a>00983                 <span class="keywordtype">float</span> *lengthd, *elev, *area;
<a name="l00984"></a>00984                 <span class="keywordtype">double</span> *pointx, *pointy;
<a name="l00985"></a>00985                 lengthd = <span class="keyword">new</span> <span class="keywordtype">float</span>[i2-i1+1];
<a name="l00986"></a>00986                 elev = <span class="keyword">new</span> <span class="keywordtype">float</span>[i2-i1+1];
<a name="l00987"></a>00987                 area = <span class="keyword">new</span> <span class="keywordtype">float</span>[i2-i1+1];
<a name="l00988"></a>00988                 pointx = <span class="keyword">new</span> <span class="keywordtype">double</span>[i2-i1+1];
<a name="l00989"></a>00989                 pointy = <span class="keyword">new</span> <span class="keywordtype">double</span>[i2-i1+1];
<a name="l00990"></a>00990                 <span class="keywordflow">for</span>(ipoint=i1;ipoint&lt;=i2;ipoint++){
<a name="l00991"></a>00991                     fprintf(fout,<span class="stringliteral">&quot;\t%f\t%f\t%f\t%f\t%f\n&quot;</span>,PointXY[ipoint][0],PointXY[ipoint][1],PointElevArea[ipoint][0],PointElevArea[ipoint][1],PointElevArea[ipoint][2]);
<a name="l00992"></a>00992                     lengthd[ipoint-i1]=PointElevArea[ipoint][0];
<a name="l00993"></a>00993                     elev[ipoint-i1]=PointElevArea[ipoint][1];
<a name="l00994"></a>00994                     area[ipoint-i1]=PointElevArea[ipoint][2];
<a name="l00995"></a>00995                     pointx[ipoint-i1]=PointXY[ipoint][0];
<a name="l00996"></a>00996                     pointy[ipoint-i1]=PointXY[ipoint][1];
<a name="l00997"></a>00997                 }
<a name="l00998"></a>00998                 <span class="comment">//  Write shape</span>
<a name="l00999"></a>00999                 <span class="keywordtype">long</span> cnet[9];
<a name="l01000"></a>01000                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iref=0; iref&lt;9; iref++)
<a name="l01001"></a>01001                     cnet[iref]=LinkIdU1U2DMagShapeidCoords[ilink][iref];
<a name="l01002"></a>01002                 reachshape(cnet,lengthd,elev,area,pointx,pointy,i2-i1+1);
<a name="l01003"></a>01003                 <span class="keyword">delete</span> lengthd; <span class="comment">// DGT to free memory</span>
<a name="l01004"></a>01004                 <span class="keyword">delete</span> elev;
<a name="l01005"></a>01005                 <span class="keyword">delete</span> area;
<a name="l01006"></a>01006                 <span class="keyword">delete</span> pointx;
<a name="l01007"></a>01007                 <span class="keyword">delete</span> pointy;
<a name="l01008"></a>01008                 <span class="comment">//if(ilink &gt; nextdot)  // Indicating progress</span>
<a name="l01009"></a>01009                 <span class="comment">//{</span>
<a name="l01010"></a>01010                 <span class="comment">//  fprintf(stderr,&quot;.&quot;);</span>
<a name="l01011"></a>01011                 <span class="comment">//  fflush(stderr);</span>
<a name="l01012"></a>01012                 <span class="comment">//  nextdot=nextdot+dotinc;</span>
<a name="l01013"></a>01013                 <span class="comment">//}</span>
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 
<a name="l01016"></a>01016             } <span class="comment">// process 0 recvs data from other processes, writes to file</span>
<a name="l01017"></a>01017             <span class="keywordflow">if</span>(myNumLinks == 0)
<a name="l01018"></a>01018                 numPointsPrinted = 0;
<a name="l01019"></a>01019             <span class="keywordflow">else</span>
<a name="l01020"></a>01020                 numPointsPrinted = LinkIdU1U2DMagShapeidCoords[myNumLinks-1][2]+1;
<a name="l01021"></a>01021             <span class="keywordflow">for</span>(i=1;i&lt;size;i++){<span class="comment">// send message to next process to wake it up</span>
<a name="l01022"></a>01022                 MPI_Send(&amp;ibuf,1,MPI_INT,i,0,MCW);<span class="comment">// get numpoints from that process</span>
<a name="l01023"></a>01023                 MPI_Recv(&amp;procNumLinks,1,MPI_INT,i,0,MCW,&amp;mystatus);<span class="comment">//get points one at a time and print them to file</span>
<a name="l01024"></a>01024                 <span class="keywordflow">if</span>(procNumLinks &gt; 0)
<a name="l01025"></a>01025                 {
<a name="l01026"></a>01026                     dotinc=procNumLinks/ndots;  <span class="comment">// For tracking progress</span>
<a name="l01027"></a>01027                     nextdot=0;
<a name="l01028"></a>01028                     <span class="keywordflow">for</span>(ilink=0;ilink&lt;procNumLinks;++ilink){
<a name="l01029"></a>01029                         MPI_Recv(&amp;treeBuf,9,MPI_LONG,i,1,MCW,&amp;mystatus);
<a name="l01030"></a>01030                         fprintf(fTreeOut,<span class="stringliteral">&quot;\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n&quot;</span>,treeBuf[0],treeBuf[1]+numPointsPrinted,treeBuf[2]+numPointsPrinted,treeBuf[3],treeBuf[4],treeBuf[5],treeBuf[6],treeBuf[7],treeBuf[8]);
<a name="l01031"></a>01031 
<a name="l01032"></a>01032                         MPI_Recv(&amp;procNumPoints,1,MPI_INT,i,0,MCW,&amp;mystatus);<span class="comment">//get points one at a time and print them to file</span>
<a name="l01033"></a>01033                 <span class="comment">// Variables for shape</span>
<a name="l01034"></a>01034                         <span class="keywordtype">float</span> *lengthd, *elev, *area;
<a name="l01035"></a>01035                         <span class="keywordtype">double</span> *pointx, *pointy;
<a name="l01036"></a>01036                         lengthd = <span class="keyword">new</span> <span class="keywordtype">float</span>[procNumPoints];
<a name="l01037"></a>01037                         elev = <span class="keyword">new</span> <span class="keywordtype">float</span>[procNumPoints];
<a name="l01038"></a>01038                         area = <span class="keyword">new</span> <span class="keywordtype">float</span>[procNumPoints];
<a name="l01039"></a>01039                         pointx = <span class="keyword">new</span> <span class="keywordtype">double</span>[procNumPoints];
<a name="l01040"></a>01040                         pointy = <span class="keyword">new</span> <span class="keywordtype">double</span>[procNumPoints];
<a name="l01041"></a>01041         
<a name="l01042"></a>01042                         <span class="keywordflow">for</span>(ipoint=0;ipoint&lt;procNumPoints;++ipoint){
<a name="l01043"></a>01043                             MPI_Recv(&amp;pbuf1,2,MPI_DOUBLE,i,1,MCW,&amp;mystatus);
<a name="l01044"></a>01044                             MPI_Recv(&amp;pbuf,3,MPI_FLOAT,i,1,MCW,&amp;mystatus);
<a name="l01045"></a>01045                             fprintf(fout,<span class="stringliteral">&quot;\t%f\t%f\t%f\t%f\t%f\n&quot;</span>,pbuf1[0],pbuf1[1],pbuf[0],pbuf[1],pbuf[2]); 
<a name="l01046"></a>01046 
<a name="l01047"></a>01047                             lengthd[ipoint]=pbuf[0];
<a name="l01048"></a>01048                             elev[ipoint]=pbuf[1];
<a name="l01049"></a>01049                             area[ipoint]=pbuf[2];
<a name="l01050"></a>01050                             pointx[ipoint]=pbuf1[0];
<a name="l01051"></a>01051                             pointy[ipoint]=pbuf1[1];
<a name="l01052"></a>01052                         }
<a name="l01053"></a>01053                         <span class="comment">//  Write shape</span>
<a name="l01054"></a>01054                         reachshape(treeBuf,lengthd,elev,area,pointx,pointy,procNumPoints);
<a name="l01055"></a>01055                         <span class="keyword">delete</span> lengthd; <span class="comment">// DGT to free memory</span>
<a name="l01056"></a>01056                         <span class="keyword">delete</span> elev;
<a name="l01057"></a>01057                         <span class="keyword">delete</span> area;
<a name="l01058"></a>01058                         <span class="keyword">delete</span> pointx;
<a name="l01059"></a>01059                         <span class="keyword">delete</span> pointy;  
<a name="l01060"></a>01060                         <span class="comment">//if(ilink &gt; nextdot)  // Indicating progress</span>
<a name="l01061"></a>01061                         <span class="comment">//{</span>
<a name="l01062"></a>01062                         <span class="comment">//  fprintf(stderr,&quot;.&quot;);</span>
<a name="l01063"></a>01063                         <span class="comment">//  fflush(stderr);</span>
<a name="l01064"></a>01064                         <span class="comment">//  nextdot=nextdot+dotinc;</span>
<a name="l01065"></a>01065                         <span class="comment">//}</span>
<a name="l01066"></a>01066 
<a name="l01067"></a>01067                     }
<a name="l01068"></a>01068                 <span class="comment">//  DGT moved line below to out of the loop so this only increments on the last link - and only if there is one</span>
<a name="l01069"></a>01069                 numPointsPrinted += treeBuf[2]+1;<span class="comment">//might need adjustmetn JJN</span>
<a name="l01070"></a>01070                 }
<a name="l01071"></a>01071             } 
<a name="l01072"></a>01072             fclose(fTreeOut);
<a name="l01073"></a>01073             fclose(fout);
<a name="l01074"></a>01074             SHPClose(shp1);
<a name="l01075"></a>01075             DBFClose(dbf1);
<a name="l01076"></a>01076             <span class="comment">/*</span>
<a name="l01077"></a>01077 <span class="comment">            shp1.close(streamnetshp);</span>
<a name="l01078"></a>01078 <span class="comment">            */</span>
<a name="l01079"></a>01079         }<span class="keywordflow">else</span>{<span class="comment">//other processes send their stuff to process 0</span>
<a name="l01080"></a>01080             <span class="comment">//first, wait to recieve word from process 0</span>
<a name="l01081"></a>01081             MPI_Recv(&amp;ibuf,1,MPI_INT,0,0,MCW,&amp;mystatus);<span class="comment">//then, send myNumPoints</span>
<a name="l01082"></a>01082             MPI_Send(&amp;myNumLinks,1,MPI_INT,0,0,MCW);<span class="comment">//pack up each point into a buffer, and send it</span>
<a name="l01083"></a>01083             <span class="keywordflow">for</span>(ilink=0;ilink&lt;myNumLinks;++ilink){
<a name="l01084"></a>01084                 treeBuf[0] = LinkIdU1U2DMagShapeidCoords[ilink][0];
<a name="l01085"></a>01085                 treeBuf[1] = LinkIdU1U2DMagShapeidCoords[ilink][1];
<a name="l01086"></a>01086                 treeBuf[2] = LinkIdU1U2DMagShapeidCoords[ilink][2];
<a name="l01087"></a>01087                 treeBuf[3] = LinkIdU1U2DMagShapeidCoords[ilink][3];
<a name="l01088"></a>01088                 treeBuf[4] = LinkIdU1U2DMagShapeidCoords[ilink][4];
<a name="l01089"></a>01089                 treeBuf[5] = LinkIdU1U2DMagShapeidCoords[ilink][5];
<a name="l01090"></a>01090                 treeBuf[6] = LinkIdU1U2DMagShapeidCoords[ilink][6];
<a name="l01091"></a>01091                 treeBuf[7] = LinkIdU1U2DMagShapeidCoords[ilink][7];
<a name="l01092"></a>01092                 treeBuf[8] = LinkIdU1U2DMagShapeidCoords[ilink][8];
<a name="l01093"></a>01093                 MPI_Send(&amp;treeBuf,9,MPI_LONG,0,1,MCW);
<a name="l01094"></a>01094                 <span class="keywordtype">int</span> ptsInLink=treeBuf[2]-treeBuf[1]+1;
<a name="l01095"></a>01095                 MPI_Send(&amp;ptsInLink,1,MPI_INT,0,0,MCW);<span class="comment">//pack up each point into a buffer, and send it</span>
<a name="l01096"></a>01096                 <span class="keywordflow">for</span>(ipoint=treeBuf[1];ipoint&lt;=treeBuf[2];++ipoint){
<a name="l01097"></a>01097                     pbuf1[0]=PointXY[ipoint][0];
<a name="l01098"></a>01098                     pbuf1[1]=PointXY[ipoint][1];
<a name="l01099"></a>01099                     pbuf[0]=PointElevArea[ipoint][0];
<a name="l01100"></a>01100                     pbuf[1]=PointElevArea[ipoint][1];
<a name="l01101"></a>01101                     pbuf[2]=PointElevArea[ipoint][2];
<a name="l01102"></a>01102                     MPI_Send(&amp;pbuf1,2,MPI_DOUBLE,0,1,MCW);
<a name="l01103"></a>01103                     MPI_Send(&amp;pbuf,3,MPI_FLOAT,0,1,MCW);
<a name="l01104"></a>01104             <span class="comment">//      MPI_Recv(&amp;ibuf,1,MPI_INT,0,0,MCW,&amp;mystatus);</span>
<a name="l01105"></a>01105                 }
<a name="l01106"></a>01106             }
<a name="l01107"></a>01107         }  <span class="comment">// just be sure we&#39;re all here</span>
<a name="l01108"></a>01108         MPI_Barrier(MCW);  <span class="comment">//DGT  This seems necessary for cluster version to work, though not sure why.</span>
<a name="l01109"></a>01109 
<a name="l01110"></a>01110         <span class="comment">// Timer - link write time</span>
<a name="l01111"></a>01111         <span class="keywordtype">double</span> linkwt = MPI_Wtime();
<a name="l01112"></a>01112         <span class="keywordflow">if</span>(rank==0)  <span class="comment">// Indicating progress</span>
<a name="l01113"></a>01113         {
<a name="l01114"></a>01114             fprintf(stderr,<span class="stringliteral">&quot;\n Calculating watersheds\n&quot;</span>);
<a name="l01115"></a>01115             fflush(stderr);
<a name="l01116"></a>01116         }
<a name="l01117"></a>01117 
<a name="l01118"></a>01118         <span class="keywordflow">if</span>(verbose)
<a name="l01119"></a>01119         {
<a name="l01120"></a>01120             cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Starting to calculate watershed&quot;</span>  &lt;&lt; endl;
<a name="l01121"></a>01121             <span class="keywordtype">int</span> messageFlag;
<a name="l01122"></a>01122             MPI_Status stat;
<a name="l01123"></a>01123             MPI_Iprobe(MPI_ANY_SOURCE, MPI_ANY_TAG, MCW, &amp;messageFlag, &amp;stat);
<a name="l01124"></a>01124             <span class="keywordflow">if</span>(messageFlag == <span class="keyword">true</span>){
<a name="l01125"></a>01125                     cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot;: I have failed to received a message!!!&quot;</span> &lt;&lt; endl;
<a name="l01126"></a>01126                     MPI_Abort(MCW,1);
<a name="l01127"></a>01127             }
<a name="l01128"></a>01128             MPI_Barrier(MCW);
<a name="l01129"></a>01129         }
<a name="l01130"></a>01130 <span class="comment">// XXXXXXXXXXXXXXXXXXXXXXXXX</span>
<a name="l01131"></a>01131 <span class="comment">//  Block to calculate watersheds</span>
<a name="l01132"></a>01132         <span class="comment">//long tempLongNodata=MISSINGLONG;</span>
<a name="l01133"></a>01133         <span class="comment">//short tempShortNodata=MISSINGSHORT;</span>
<a name="l01134"></a>01134 
<a name="l01135"></a>01135         <span class="comment">//tdpartition *temp111;</span>
<a name="l01136"></a>01136         <span class="comment">//temp111 = CreateNewPartition(SHORT_TYPE, TotalX, TotalY, dx, dy, MISSINGSHORT);</span>
<a name="l01137"></a>01137         <span class="comment">//for(i=0; i&lt;nx; i++)</span>
<a name="l01138"></a>01138         <span class="comment">//  for(j=0; j&lt;ny; j++)</span>
<a name="l01139"></a>01139         <span class="comment">//  {</span>
<a name="l01140"></a>01140         <span class="comment">//      if(!wsGrid-&gt;isNodata(i,j))</span>
<a name="l01141"></a>01141         <span class="comment">//          temp111-&gt;setData(i,j,(short)wsGrid-&gt;getData(i,j,tempLong));</span>
<a name="l01144"></a>01144 <span class="comment"></span>        <span class="comment">//  }</span>
<a name="l01145"></a>01145 
<a name="l01146"></a>01146 <span class="comment">//      tiffIO ws1IO(&quot;wfile.tif&quot;, SHORT_TYPE,&amp;tempShortNodata,ad8IO);</span>
<a name="l01147"></a>01147 <span class="comment">//      ws1IO.write(xstart, ystart, ny, nx, temp111-&gt;getGridPointer());</span>
<a name="l01148"></a>01148 <span class="comment">//      tiffIO id1IO(&quot;idfile.tif&quot;, LONG_TYPE,&amp;tempLongNodata,ad8IO);</span>
<a name="l01149"></a>01149 <span class="comment">//      id1IO.write(xstart, ystart, ny, nx, idGrid-&gt;getGridPointer());</span>
<a name="l01150"></a>01150 
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 
<a name="l01153"></a>01153         <span class="comment">//Calculate watersheds....</span>
<a name="l01154"></a>01154         <span class="comment">//  Reinitialize partition to delete leftovers from process above</span>
<a name="l01155"></a>01155         <span class="keyword">delete</span> contribs;
<a name="l01156"></a>01156         contribs = CreateNewPartition(SHORT_TYPE, TotalX, TotalY, dx, dy, MISSINGSHORT);
<a name="l01157"></a>01157         <span class="comment">//MPI_Barrier(MCW);</span>
<a name="l01158"></a>01158         <span class="keywordflow">for</span>(j=0;j&lt;ny;++j){
<a name="l01159"></a>01159             <span class="keywordflow">for</span>(i=0;i&lt;nx;++i){
<a name="l01160"></a>01160                 <span class="comment">// If my downslope neighbor has an id, contribs is 0 and I am ready to evaluate so go on q, else contribs is 1</span>
<a name="l01161"></a>01161                 <span class="keywordflow">if</span>(!flowDir-&gt;isNodata(i,j))
<a name="l01162"></a>01162                 {   <span class="comment">//  Only put on queue to do if it is off the stream network</span>
<a name="l01163"></a>01163                     <span class="keywordflow">if</span>(src-&gt;isNodata(i,j) || src-&gt;getData(i,j,tempShort) &lt; 1) <span class="comment">//idGrid-&gt;isNodata(i,j))  //  Only if it is no data do we have to do anything </span>
<a name="l01164"></a>01164                     {
<a name="l01165"></a>01165                         p=flowDir-&gt;getData(i,j,tempShort);
<a name="l01166"></a>01166                         inext=i+d1[p];
<a name="l01167"></a>01167                         jnext=j+d2[p];
<a name="l01168"></a>01168                         <span class="keywordflow">if</span>(src-&gt;hasAccess(inext,jnext))  <span class="comment">//  Only do anything with cells for which we have access to downslope cell</span>
<a name="l01169"></a>01169                         {
<a name="l01170"></a>01170                             <span class="keywordflow">if</span>(src-&gt;isNodata(inext,jnext) || src-&gt;getData(inext,jnext,tempShort) &lt; 1){ <span class="comment">//idGrid-&gt;isNodata(inext,jnext))</span>
<a name="l01171"></a>01171                                 contribs-&gt;setData(i,j,(<span class="keywordtype">short</span>)1);  <span class="comment">//  downslope cell not on stream</span>
<a name="l01172"></a>01172                                 wsGrid-&gt;setToNodata(i,j);  <span class="comment">// overwrite grid value that may have been inherited from outlet not on stream</span>
<a name="l01173"></a>01173                             }
<a name="l01174"></a>01174                             <span class="keywordflow">else</span>
<a name="l01175"></a>01175                             {
<a name="l01176"></a>01176                                 contribs-&gt;setData(i,j,(<span class="keywordtype">short</span>)0); <span class="comment">//  downslope cell on stream</span>
<a name="l01177"></a>01177                                 t.x=i;
<a name="l01178"></a>01178                                 t.y=j;
<a name="l01179"></a>01179                                 que.push(t);
<a name="l01180"></a>01180                             }
<a name="l01181"></a>01181                         }
<a name="l01182"></a>01182                     }<span class="comment">//  Here on stream</span>
<a name="l01183"></a>01183                     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ordert==0)  <span class="comment">// Ordert = 0 indicates that all watersheds are to be labeled with the number 1</span>
<a name="l01184"></a>01184                     {
<a name="l01185"></a>01185                         tempLong=1;  
<a name="l01186"></a>01186                         wsGrid-&gt;setData(i,j,tempLong);
<a name="l01187"></a>01187                     }
<a name="l01188"></a>01188                 }
<a name="l01189"></a>01189             }
<a name="l01190"></a>01190         }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192         <span class="keywordflow">if</span>(verbose)
<a name="l01193"></a>01193         {
<a name="l01194"></a>01194             cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Watershed initialization complete&quot;</span>  &lt;&lt; endl;
<a name="l01195"></a>01195         }
<a name="l01196"></a>01196         <span class="comment">// each process empties its que, then shares border info, and repeats till everyone is done</span>
<a name="l01197"></a>01197         finished=<span class="keyword">false</span>;
<a name="l01198"></a>01198         <span class="keywordflow">while</span>(!finished){
<a name="l01199"></a>01199             contribs-&gt;clearBorders();
<a name="l01200"></a>01200             <span class="keywordflow">while</span>(!que.empty()){
<a name="l01201"></a>01201                 t=que.front();
<a name="l01202"></a>01202                 que.pop();
<a name="l01203"></a>01203                 i = t.x;
<a name="l01204"></a>01204                 j = t.y;
<a name="l01205"></a>01205                 p=flowDir-&gt;getData(i,j,tempShort);
<a name="l01206"></a>01206                 inext=i+d1[p];
<a name="l01207"></a>01207                 jnext=j+d2[p];
<a name="l01208"></a>01208                 <span class="keywordflow">if</span>(ordert &gt; 0){  <span class="comment">// Ordert &gt; 0 indicates that all watersheds are to be labeled with different numbers</span>
<a name="l01209"></a>01209                     wsGrid-&gt;setData(i,j,wsGrid-&gt;getData(inext,jnext,tempLong));
<a name="l01210"></a>01210                     <span class="comment">//cout &lt;&lt; tempLong;</span>
<a name="l01211"></a>01211                 }<span class="keywordflow">else</span>
<a name="l01212"></a>01212                 {
<a name="l01213"></a>01213                     tempLong=1;  <span class="comment">// Ordert = 0 indicates that all watersheds are to be labeled with the number 1</span>
<a name="l01214"></a>01214                     wsGrid-&gt;setData(i,j,tempLong);
<a name="l01215"></a>01215                 }
<a name="l01216"></a>01216                 <span class="comment">//  Now find all cells that point to me and decrease contribs and put on queue if necessary</span>
<a name="l01217"></a>01217                 <span class="keywordflow">for</span>(m=1;m&lt;=8;++m){
<a name="l01218"></a>01218                     inext=i+d1[m];
<a name="l01219"></a>01219                     jnext=j+d2[m];
<a name="l01220"></a>01220                     <span class="keywordflow">if</span>(pointsToMe(i,j,inext,jnext,flowDir))
<a name="l01221"></a>01221                     {
<a name="l01222"></a>01222                         contribs-&gt;addToData(inext,jnext,(<span class="keywordtype">short</span>)(-1));
<a name="l01223"></a>01223                         <span class="keywordflow">if</span>(contribs-&gt;isInPartition(inext,jnext) &amp;&amp; contribs-&gt;getData(inext,jnext,tempShort)==0)
<a name="l01224"></a>01224                         {
<a name="l01225"></a>01225                             t.x=inext;
<a name="l01226"></a>01226                             t.y=jnext;
<a name="l01227"></a>01227                             que.push(t);
<a name="l01228"></a>01228                         }
<a name="l01229"></a>01229                     }
<a name="l01230"></a>01230                 }
<a name="l01231"></a>01231             }
<a name="l01232"></a>01232             <span class="comment">//Pass information across partitions</span>
<a name="l01233"></a>01233             contribs-&gt;addBorders();
<a name="l01234"></a>01234             wsGrid-&gt;share();
<a name="l01235"></a>01235             <span class="keywordflow">for</span>(i=0; i&lt;nx; i++){
<a name="l01236"></a>01236                 <span class="keywordflow">if</span>(contribs-&gt;getData(i, -1, tempShort)!=0 &amp;&amp; contribs-&gt;getData(i, 0, tempShort)==0)<span class="comment">//only looks at one direction of flow, out of a partition</span>
<a name="l01237"></a>01237                 {
<a name="l01238"></a>01238                     t.x = i;
<a name="l01239"></a>01239                     t.y = 0;
<a name="l01240"></a>01240                     que.push(t);
<a name="l01241"></a>01241                 }
<a name="l01242"></a>01242                 <span class="keywordflow">if</span>(contribs-&gt;getData(i, ny, tempShort) != 0 &amp;&amp; contribs-&gt;getData(i, ny-1, tempShort)==0)<span class="comment">//only looks at one direction of flow, out of a partition</span>
<a name="l01243"></a>01243                 {
<a name="l01244"></a>01244                     t.x = i;
<a name="l01245"></a>01245                     t.y = ny-1;
<a name="l01246"></a>01246                     que.push(t); 
<a name="l01247"></a>01247                 }
<a name="l01248"></a>01248             }
<a name="l01249"></a>01249             <span class="comment">//Check if done</span>
<a name="l01250"></a>01250             finished = que.empty();
<a name="l01251"></a>01251             finished = contribs-&gt;ringTerm(finished);
<a name="l01252"></a>01252         }
<a name="l01253"></a>01253         <span class="comment">// Timer - watershed label time</span>
<a name="l01254"></a>01254         <span class="keywordtype">double</span> wshedlabt = MPI_Wtime();
<a name="l01255"></a>01255         <span class="keywordflow">if</span>(verbose)
<a name="l01256"></a>01256         {
<a name="l01257"></a>01257             cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Writing watershed file&quot;</span>  &lt;&lt; endl;
<a name="l01258"></a>01258         }
<a name="l01259"></a>01259     
<a name="l01260"></a>01260 
<a name="l01261"></a>01261         <span class="keywordtype">long</span> wsGridNodata=MISSINGLONG;
<a name="l01262"></a>01262         <span class="keywordtype">short</span> ordNodata=MISSINGSHORT;
<a name="l01263"></a>01263         tiffIO wsIO(wfile, LONG_TYPE,&amp;wsGridNodata,ad8IO);
<a name="l01264"></a>01264         wsIO.write(xstart, ystart, ny, nx, wsGrid-&gt;getGridPointer());
<a name="l01265"></a>01265         <span class="keywordflow">if</span>(verbose)
<a name="l01266"></a>01266         {
<a name="l01267"></a>01267             cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Assigning order array&quot;</span>  &lt;&lt; endl;
<a name="l01268"></a>01268         }
<a name="l01269"></a>01269 
<a name="l01270"></a>01270 
<a name="l01271"></a>01271         <span class="comment">//  Use contribs as a short to write out order data that was held in lengths</span>
<a name="l01272"></a>01272         tempShort=0;
<a name="l01273"></a>01273         <span class="keywordflow">for</span>(i=0; i&lt;nx; i++)
<a name="l01274"></a>01274             <span class="keywordflow">for</span>(j=0; j&lt;ny; j++)
<a name="l01275"></a>01275             {
<a name="l01276"></a>01276                 contribs-&gt;setData(i,j,tempShort);
<a name="l01277"></a>01277                 <span class="keywordflow">if</span>(!lengths-&gt;isNodata(i,j))
<a name="l01278"></a>01278                     contribs-&gt;setData(i,j,(<span class="keywordtype">short</span>)lengths-&gt;getData(i,j,tempFloat));
<a name="l01279"></a>01279             }
<a name="l01280"></a>01280         <span class="keywordflow">if</span>(verbose)
<a name="l01281"></a>01281         {
<a name="l01282"></a>01282             cout &lt;&lt; rank &lt;&lt; <span class="stringliteral">&quot; Writing order file&quot;</span>  &lt;&lt; endl;
<a name="l01283"></a>01283         }
<a name="l01284"></a>01284         tiffIO ordIO(ordfile, SHORT_TYPE,&amp;ordNodata,ad8IO);
<a name="l01285"></a>01285         ordIO.write(xstart, ystart, ny, nx, contribs-&gt;getGridPointer());
<a name="l01286"></a>01286         
<a name="l01287"></a>01287         <span class="comment">// Timer - write time</span>
<a name="l01288"></a>01288         <span class="keywordtype">double</span> writet = MPI_Wtime();
<a name="l01289"></a>01289         <span class="keywordtype">double</span> dataRead, lengthc, linkc, linkw, wshedlab,  write, total,tempd;
<a name="l01290"></a>01290         dataRead = readt-begint;
<a name="l01291"></a>01291     lengthc = lengthct-readt;
<a name="l01292"></a>01292         linkc = linkct-lengthct;
<a name="l01293"></a>01293     linkw = linkwt - linkct;
<a name="l01294"></a>01294     wshedlab = wshedlabt - linkwt;
<a name="l01295"></a>01295         write = writet-wshedlabt;
<a name="l01296"></a>01296         total = writet - begint;
<a name="l01297"></a>01297 
<a name="l01298"></a>01298         MPI_Allreduce (&amp;dataRead, &amp;tempd, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l01299"></a>01299         dataRead = tempd/size;
<a name="l01300"></a>01300         MPI_Allreduce (&amp;lengthc, &amp;tempd, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l01301"></a>01301         lengthc = tempd/size;
<a name="l01302"></a>01302         MPI_Allreduce (&amp;linkc, &amp;tempd, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l01303"></a>01303         linkc = tempd/size;
<a name="l01304"></a>01304         MPI_Allreduce (&amp;linkw, &amp;tempd, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l01305"></a>01305         linkw = tempd/size;
<a name="l01306"></a>01306         MPI_Allreduce (&amp;wshedlab, &amp;tempd, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l01307"></a>01307         wshedlab = tempd/size;
<a name="l01308"></a>01308         MPI_Allreduce (&amp;write, &amp;tempd, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l01309"></a>01309         write = tempd/size;
<a name="l01310"></a>01310         MPI_Allreduce (&amp;total, &amp;tempd, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l01311"></a>01311         total = tempd/size;
<a name="l01312"></a>01312 
<a name="l01313"></a>01313         <span class="keywordflow">if</span>( rank == 0){
<a name="l01314"></a>01314             <span class="comment">//printf(&quot;Processors: %d\nRead time: %f\nLength compute time: %f\nLink compute time: %f\nLink write time: %f\nWatershed compute time: %f\nWrite time: %f\nTotal time: %f\n&quot;, size, dataRead, lengthc, linkc, linkw, wshedlab, write,total);</span>
<a name="l01315"></a>01315             printf(<span class="stringliteral">&quot;Processors: %d\nRead time: %f\nCompute time: %f\nWrite time: %f\nTotal time: %f\n&quot;</span>, size, dataRead, lengthc+linkc+wshedlab,linkw + write,total);
<a name="l01316"></a>01316         }
<a name="l01317"></a>01317 
<a name="l01318"></a>01318 
<a name="l01319"></a>01319     }MPI_Finalize();
<a name="l01320"></a>01320     <span class="keywordflow">return</span> 0;
<a name="l01321"></a>01321 }
<a name="l01322"></a>01322 
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->

</div>
</div>
</div>
</div>
</div>

<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 13 2016 11:04:21 for SEIMS-2016 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="$relpath^doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
