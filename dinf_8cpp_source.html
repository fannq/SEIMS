<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SEIMS-2016: preprocess/cpp_src/TauDEM/dinf.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SEIMS-2016
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Spatially Explicit Integrated Modeling System</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">preprocess/cpp_src/TauDEM/dinf.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*  DinfFlowDir function to compute flow direction based on D-infinity flow model.</span>
<a name="l00002"></a>00002 <span class="comment">     </span>
<a name="l00003"></a>00003 <span class="comment">  David Tarboton, Jeremy Neff, Dan Watson</span>
<a name="l00004"></a>00004 <span class="comment">  Utah State University  </span>
<a name="l00005"></a>00005 <span class="comment">  May 23, 2010 </span>
<a name="l00006"></a>00006 <span class="comment">  </span>
<a name="l00007"></a>00007 <span class="comment">*/</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="comment">/*  Copyright (C) 2010  David Tarboton, Utah State University</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">This program is free software; you can redistribute it and/or</span>
<a name="l00012"></a>00012 <span class="comment">modify it under the terms of the GNU General Public License </span>
<a name="l00013"></a>00013 <span class="comment">version 2, 1991 as published by the Free Software Foundation.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">This program is distributed in the hope that it will be useful,</span>
<a name="l00016"></a>00016 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00017"></a>00017 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00018"></a>00018 <span class="comment">GNU General Public License for more details.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">A copy of the full GNU General Public License is included in file </span>
<a name="l00021"></a>00021 <span class="comment">gpl.html. This is also available at:</span>
<a name="l00022"></a>00022 <span class="comment">http://www.gnu.org/copyleft/gpl.html</span>
<a name="l00023"></a>00023 <span class="comment">or from:</span>
<a name="l00024"></a>00024 <span class="comment">The Free Software Foundation, Inc., 59 Temple Place - Suite 330, </span>
<a name="l00025"></a>00025 <span class="comment">Boston, MA  02111-1307, USA.</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">If you wish to use or incorporate this program (or parts of it) into </span>
<a name="l00028"></a>00028 <span class="comment">other software that does not meet the GNU General Public License </span>
<a name="l00029"></a>00029 <span class="comment">conditions contact the author to request permission.</span>
<a name="l00030"></a>00030 <span class="comment">David G. Tarboton  </span>
<a name="l00031"></a>00031 <span class="comment">Utah State University </span>
<a name="l00032"></a>00032 <span class="comment">8200 Old Main Hill </span>
<a name="l00033"></a>00033 <span class="comment">Logan, UT 84322-8200 </span>
<a name="l00034"></a>00034 <span class="comment">USA </span>
<a name="l00035"></a>00035 <span class="comment">http://www.engineering.usu.edu/dtarb/ </span>
<a name="l00036"></a>00036 <span class="comment">email:  dtarb@usu.edu </span>
<a name="l00037"></a>00037 <span class="comment">*/</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="comment">//  This software is distributed from http://hydrology.usu.edu/taudem/</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;linearpart.h&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;createpart.h&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;commonLib.h&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;tiffIO.h&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;Node.h&quot;</span>
<a name="l00048"></a>00048 <span class="keyword">using namespace </span>std;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keywordtype">double</span> fact[9];
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">//int setPosDirDinf(tdpartition *elevDEM, tdpartition *flowDir, tdpartition *slope, tdpartition *area, int useflowfile);</span>
<a name="l00053"></a>00053 <span class="keywordtype">long</span> setPosDirDinf(tdpartition *elevDEM, tdpartition *flowDir, tdpartition *slope, <span class="keywordtype">int</span> useflowfile);
<a name="l00054"></a>00054 <span class="keywordtype">long</span> resolveflats( tdpartition *elevDEM, tdpartition *flowDir, queue&lt;node&gt; *que, <span class="keywordtype">bool</span> &amp;first);
<a name="l00055"></a>00055 <span class="comment">//Checks if cells cross</span>
<a name="l00056"></a>00056 <span class="keywordtype">int</span> dontCross( <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, tdpartition *flowDir) {
<a name="l00057"></a>00057     <span class="keywordtype">long</span> n1, n2, c1, c2, ans=0;
<a name="l00058"></a>00058     <span class="keywordtype">long</span> in1,jn1,in2,jn2;
<a name="l00059"></a>00059     <span class="keywordtype">short</span> tempShort;
<a name="l00060"></a>00060     <span class="keywordtype">float</span> tempFloat;
<a name="l00061"></a>00061     <span class="keywordflow">switch</span>(k){
<a name="l00062"></a>00062         <span class="keywordflow">case</span> 2:
<a name="l00063"></a>00063             n1=1; c1=4; n2=3; c2=8;
<a name="l00064"></a>00064             in1=i+d1[n1];
<a name="l00065"></a>00065             jn1=j+d2[n1];
<a name="l00066"></a>00066             in2=i+d1[n2];
<a name="l00067"></a>00067             jn2=j+d2[n2];
<a name="l00068"></a>00068             <span class="keywordflow">if</span>( (flowDir-&gt;getData(in1,jn1,tempFloat)) == c1 || (flowDir-&gt;getData(in2,jn2,tempFloat)) == c2)
<a name="l00069"></a>00069                 ans=1;
<a name="l00070"></a>00070                     <span class="keywordflow">break</span>;
<a name="l00071"></a>00071         <span class="keywordflow">case</span> 4:
<a name="l00072"></a>00072             n1=3; c1=6; n2=5; c2=2;
<a name="l00073"></a>00073             in1=i+d1[n1];
<a name="l00074"></a>00074             jn1=j+d2[n1];
<a name="l00075"></a>00075             in2=i+d1[n2];
<a name="l00076"></a>00076             jn2=j+d2[n2];
<a name="l00077"></a>00077             <span class="keywordflow">if</span>( (flowDir-&gt;getData(in1,jn1,tempFloat)) == c1 || (flowDir-&gt;getData(in2,jn2,tempFloat)) == c2)
<a name="l00078"></a>00078                         ans=1;
<a name="l00079"></a>00079                     <span class="keywordflow">break</span>;
<a name="l00080"></a>00080             <span class="keywordflow">case</span> 6:
<a name="l00081"></a>00081                     n1=7; c1=4; n2=5; c2=8;
<a name="l00082"></a>00082             in1=i+d1[n1];
<a name="l00083"></a>00083             jn1=j+d2[n1];
<a name="l00084"></a>00084             in2=i+d1[n2];
<a name="l00085"></a>00085             jn2=j+d2[n2];
<a name="l00086"></a>00086             <span class="keywordflow">if</span>( (flowDir-&gt;getData(in1,jn1,tempFloat) == c1 ) )
<a name="l00087"></a>00087                         ans=1;
<a name="l00088"></a>00088             <span class="keywordflow">if</span> (flowDir-&gt;getData(in2,jn2,tempFloat) == c2 )
<a name="l00089"></a>00089                         ans=1;
<a name="l00090"></a>00090                     <span class="keywordflow">break</span>;
<a name="l00091"></a>00091             <span class="keywordflow">case</span> 8:
<a name="l00092"></a>00092             n1=1; c1=6; n2=7; c2=2;
<a name="l00093"></a>00093             in1=i+d1[n1];
<a name="l00094"></a>00094             jn1=j+d2[n1];
<a name="l00095"></a>00095             in2=i+d1[n2];
<a name="l00096"></a>00096             jn2=j+d2[n2];
<a name="l00097"></a>00097             <span class="keywordflow">if</span>( (flowDir-&gt;getData(in1,jn1,tempFloat)) == c1 || (flowDir-&gt;getData(in2,jn2,tempFloat)) == c2)
<a name="l00098"></a>00098                             ans=1;
<a name="l00099"></a>00099                     <span class="keywordflow">break</span>;
<a name="l00100"></a>00100         <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102     <span class="keywordflow">return</span>(ans);
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment">//Set positive flowdirections of elevDEM</span>
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="keywordtype">int</span> setdir( <span class="keywordtype">char</span>* demfile, <span class="keywordtype">char</span>* angfile, <span class="keywordtype">char</span> *slopefile, <span class="keywordtype">char</span> *flowfile, <span class="keywordtype">int</span> useflowfile) {
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     MPI_Init(NULL,NULL);{
<a name="l00110"></a>00110 
<a name="l00111"></a>00111     <span class="comment">//Only needed to output time</span>
<a name="l00112"></a>00112     <span class="keywordtype">int</span> rank,size;
<a name="l00113"></a>00113     MPI_Comm_rank(MCW,&amp;rank);
<a name="l00114"></a>00114     MPI_Comm_size(MCW,&amp;size);
<a name="l00115"></a>00115     <span class="keywordflow">if</span>(rank==0)
<a name="l00116"></a>00116     {
<a name="l00117"></a>00117         printf(<span class="stringliteral">&quot;DinfFlowDir version %s\n&quot;</span>,TDVERSION);
<a name="l00118"></a>00118         fflush(stdout);
<a name="l00119"></a>00119     }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="keywordtype">double</span> begint = MPI_Wtime();
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">//Read DEM from file</span>
<a name="l00124"></a>00124 <span class="comment">//  printf(&quot;Before demread rank: %d\n&quot;,rank);</span>
<a name="l00125"></a>00125     tiffIO dem(demfile, FLOAT_TYPE);
<a name="l00126"></a>00126     <span class="keywordtype">long</span> totalX = dem.getTotalX();
<a name="l00127"></a>00127     <span class="keywordtype">long</span> totalY = dem.getTotalY();
<a name="l00128"></a>00128     <span class="keywordtype">double</span> dx = dem.getdx();
<a name="l00129"></a>00129     <span class="keywordtype">double</span> dy = dem.getdy();
<a name="l00130"></a>00130     
<a name="l00131"></a>00131     tdpartition *elevDEM;
<a name="l00132"></a>00132     elevDEM = CreateNewPartition(dem.getDatatype(), totalX, totalY, dx, dy, dem.getNodata());
<a name="l00133"></a>00133     <span class="keywordtype">int</span> xstart, ystart;
<a name="l00134"></a>00134     <span class="keywordtype">int</span> nx = elevDEM-&gt;getnx();
<a name="l00135"></a>00135     <span class="keywordtype">int</span> ny = elevDEM-&gt;getny();
<a name="l00136"></a>00136     elevDEM-&gt;localToGlobal(0, 0, xstart, ystart);
<a name="l00137"></a>00137     <span class="keywordtype">double</span> headert = MPI_Wtime();
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     <span class="comment">//if(rank==0)</span>
<a name="l00140"></a>00140     <span class="comment">//{</span>
<a name="l00141"></a>00141     <span class="comment">//  float timeestimate=(2.8e-9*pow((double)(totalX*totalY),1.55)/pow((double) size,0.65))/60+1;  // Time estimate in minutes</span>
<a name="l00142"></a>00142     <span class="comment">//  //fprintf(stderr,&quot;%d %d %d\n&quot;,totalX,totalY,size);</span>
<a name="l00143"></a>00143     <span class="comment">//  fprintf(stderr,&quot;This run may take on the order of %.0f minutes to complete.\n&quot;,timeestimate);</span>
<a name="l00144"></a>00144     <span class="comment">//  fprintf(stderr,&quot;This estimate is very approximate. \nRun time is highly uncertain as it depends on the complexity of the input data \nand speed and memory of the computer. This estimate is based on our testing on \na dual quad core Dell Xeon E5405 2.0GHz PC with 16GB RAM.\n&quot;);</span>
<a name="l00145"></a>00145     <span class="comment">//  fflush(stderr);</span>
<a name="l00146"></a>00146     <span class="comment">//}</span>
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 
<a name="l00149"></a>00149     dem.read(xstart, ystart, ny, nx, elevDEM-&gt;getGridPointer());
<a name="l00150"></a>00150     elevDEM-&gt;share();
<a name="l00151"></a>00151 
<a name="l00152"></a>00152     <span class="keywordtype">double</span> readt = MPI_Wtime();
<a name="l00153"></a>00153     
<a name="l00154"></a>00154     <span class="comment">//Creates empty partition to store new flow direction </span>
<a name="l00155"></a>00155     tdpartition *flowDir;
<a name="l00156"></a>00156     flowDir = CreateNewPartition(FLOAT_TYPE, totalX, totalY, dx, dy, MISSINGFLOAT);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     <span class="comment">//If using flowfile is enabled, read it in</span>
<a name="l00159"></a>00159     <span class="comment">//tdpartition *imposedflow, *area;</span>
<a name="l00160"></a>00160     <span class="comment">//area = CreateNewPartition(LONG_TYPE, totalX, totalY, dx, dy, MISSINGLONG);</span>
<a name="l00161"></a>00161 <span class="comment">//  area = new linearpart&lt;long&gt;;</span>
<a name="l00162"></a>00162 <span class="comment">//  area-&gt;init(totalX, totalY, dx, dy, MPI_LONG, long(-1));</span>
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="comment">//if( useflowfile == 1) {</span>
<a name="l00165"></a>00165     <span class="comment">//  tiffIO flow(flowfile,SHORT_TYPE);</span>
<a name="l00166"></a>00166     <span class="comment">//  imposedflow = CreateNewPartition(flow.getDatatype(), flow.getTotalX(), flow.getTotalY(), flow.getdx(), flow.getdy(), flow.getNodata());</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <span class="comment">//  if(!dem.compareTiff(flow)) {</span>
<a name="l00169"></a>00169     <span class="comment">//      printf(&quot;Error using imposed flow file.\n&quot;); </span>
<a name="l00170"></a>00170     <span class="comment">//      return 1;</span>
<a name="l00171"></a>00171     <span class="comment">//  }</span>
<a name="l00172"></a>00172     <span class="comment">//  </span>
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <span class="comment">//  int i,j;</span>
<a name="l00176"></a>00176     <span class="comment">//  for( j = 0; j &lt; elevDEM-&gt;getny(); j++) {</span>
<a name="l00177"></a>00177     <span class="comment">//      for( i=0; i &lt; elevDEM-&gt;getnx(); i++ ) {</span>
<a name="l00178"></a>00178     <span class="comment">//          short data;</span>
<a name="l00179"></a>00179     <span class="comment">//          imposedflow-&gt;getData(i,j,data);</span>
<a name="l00180"></a>00180     <span class="comment">//          if (imposedflow-&gt;isNodata(i,j) || !imposedflow-&gt;hasAccess(i-1,j) || !imposedflow-&gt;hasAccess(i+1,j) ||</span>
<a name="l00181"></a>00181     <span class="comment">//              !imposedflow-&gt;hasAccess(i,j-1) || !imposedflow-&gt;hasAccess(i,j+1)){</span>
<a name="l00182"></a>00182     <span class="comment">//              //Do nothing</span>
<a name="l00183"></a>00183     <span class="comment">//          }</span>
<a name="l00184"></a>00184     <span class="comment">//          else if((data&gt;0) &amp;&amp; data &lt;=8 ) </span>
<a name="l00185"></a>00185     <span class="comment">//                  flowDir-&gt;setData(i,j,(float)data);</span>
<a name="l00186"></a>00186     <span class="comment">//      }</span>
<a name="l00187"></a>00187     <span class="comment">//  }</span>
<a name="l00189"></a>00189 <span class="comment"></span>    <span class="comment">//  //TODO - why is this here?</span>
<a name="l00190"></a>00190     <span class="comment">//  //darea( &amp;flowDir, &amp;area, NULL, NULL, 0, 1, NULL, 0, 0 );</span>
<a name="l00191"></a>00191     <span class="comment">//}</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     <span class="comment">//Creates empty partition to store new slopes</span>
<a name="l00194"></a>00194     <span class="keywordtype">long</span> numFlat, totalNumFlat, lastNumFlat;
<a name="l00195"></a>00195     <span class="keywordtype">double</span> computeSlopet;
<a name="l00196"></a>00196     {
<a name="l00197"></a>00197     tdpartition *slope;
<a name="l00198"></a>00198     <span class="keywordtype">float</span> slopeNodata = -1.0f;
<a name="l00199"></a>00199     slope = CreateNewPartition(FLOAT_TYPE, totalX, totalY, dx, dy, slopeNodata);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="comment">//numFlat = setPosDirDinf(elevDEM, flowDir, slope, area, useflowfile);</span>
<a name="l00202"></a>00202     numFlat = setPosDirDinf(elevDEM, flowDir, slope, useflowfile);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <span class="comment">//Stop timer</span>
<a name="l00205"></a>00205     computeSlopet = MPI_Wtime();
<a name="l00206"></a>00206     tiffIO slopeIO(slopefile, FLOAT_TYPE, &amp;slopeNodata, dem);
<a name="l00207"></a>00207     slopeIO.write(xstart, ystart, ny, nx, slope-&gt;getGridPointer());
<a name="l00208"></a>00208     }  <span class="comment">// This bracket intended to destruct slope partition and release memory</span>
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     <span class="keywordtype">double</span> writeSlopet = MPI_Wtime();
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     MPI_Allreduce(&amp;numFlat,&amp;totalNumFlat,1,MPI_LONG,MPI_SUM,MCW);
<a name="l00213"></a>00213     <span class="comment">//if(rank==0)</span>
<a name="l00214"></a>00214     <span class="comment">//{</span>
<a name="l00215"></a>00215     <span class="comment">//  fprintf(stderr,&quot;All slopes evaluated. %ld flats to resolve.\n&quot;,totalNumFlat);</span>
<a name="l00216"></a>00216     <span class="comment">//  fflush(stderr);</span>
<a name="l00217"></a>00217     <span class="comment">//}</span>
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     queue&lt;node&gt; que;  <span class="comment">//  que to be used in resolveflats</span>
<a name="l00220"></a>00220     <span class="keywordtype">bool</span> first=<span class="keyword">true</span>;  <span class="comment">//  Variable to be used in iteration to know whether first or subsequent iteration</span>
<a name="l00221"></a>00221     <span class="keywordflow">if</span>( totalNumFlat &gt; 0)
<a name="l00222"></a>00222     {
<a name="l00223"></a>00223         lastNumFlat=totalNumFlat;
<a name="l00224"></a>00224         totalNumFlat = resolveflats(elevDEM, flowDir, &amp;que, first);  
<a name="l00225"></a>00225         <span class="comment">//Repeatedly call resolve flats until there is no change </span>
<a name="l00226"></a>00226         <span class="keywordflow">while</span>(totalNumFlat &gt; 0  &amp;&amp; totalNumFlat &lt; lastNumFlat)
<a name="l00227"></a>00227         {
<a name="l00228"></a>00228             <span class="comment">//if(rank==0)</span>
<a name="l00229"></a>00229             <span class="comment">//{</span>
<a name="l00230"></a>00230             <span class="comment">//  fprintf(stderr,&quot;Iteration complete. Number of flats remaining: %ld\n&quot;,totalNumFlat);</span>
<a name="l00231"></a>00231             <span class="comment">//  fflush(stderr);</span>
<a name="l00232"></a>00232             <span class="comment">//}</span>
<a name="l00233"></a>00233             lastNumFlat=totalNumFlat;
<a name="l00234"></a>00234             totalNumFlat = resolveflats(elevDEM, flowDir, &amp;que, first);
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="comment">//Timing info</span>
<a name="l00239"></a>00239     <span class="keywordtype">double</span> computeFlatt = MPI_Wtime();
<a name="l00240"></a>00240 <span class="comment">//  printf(&quot;Before angwrite rank: %d\n&quot;,rank);</span>
<a name="l00241"></a>00241     <span class="keywordtype">float</span> flowDirNodata=MISSINGFLOAT;
<a name="l00242"></a>00242     tiffIO flowIO(angfile, FLOAT_TYPE, &amp;flowDirNodata, dem);
<a name="l00243"></a>00243     flowIO.write(xstart, ystart, ny, nx, flowDir-&gt;getGridPointer());
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <span class="keywordtype">double</span> writet = MPI_Wtime();
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         <span class="keywordtype">double</span> headerRead, dataRead, computeSlope, writeSlope, computeFlat,writeFlat, write, total,temp;
<a name="l00248"></a>00248         headerRead = headert-begint;
<a name="l00249"></a>00249         dataRead = readt-headert;
<a name="l00250"></a>00250         computeSlope = computeSlopet-readt;
<a name="l00251"></a>00251         writeSlope = writeSlopet-computeSlopet;
<a name="l00252"></a>00252         computeFlat = computeFlatt-writeSlopet;
<a name="l00253"></a>00253         writeFlat = writet-computeFlatt;
<a name="l00254"></a>00254         total = writet - begint;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         MPI_Allreduce (&amp;headerRead, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00257"></a>00257         headerRead = temp/size;
<a name="l00258"></a>00258         MPI_Allreduce (&amp;dataRead, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00259"></a>00259         dataRead = temp/size;
<a name="l00260"></a>00260         MPI_Allreduce (&amp;computeSlope, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00261"></a>00261         computeSlope = temp/size;
<a name="l00262"></a>00262         MPI_Allreduce (&amp;computeFlat, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00263"></a>00263         computeFlat = temp/size;
<a name="l00264"></a>00264         MPI_Allreduce (&amp;writeSlope, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00265"></a>00265         writeSlope = temp/size;
<a name="l00266"></a>00266         MPI_Allreduce (&amp;writeFlat, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00267"></a>00267         writeFlat = temp/size;
<a name="l00268"></a>00268         MPI_Allreduce (&amp;total, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00269"></a>00269         total = temp/size;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271         <span class="keywordflow">if</span>( rank == 0){
<a name="l00272"></a>00272                 <span class="comment">//  These times are only for  process 0 - not averaged across processors.  This may be an approximation - but probably do not want to hold processes up to synchronize just so as to get more accurate timing</span>
<a name="l00273"></a>00273                 <span class="comment">//printf(&quot;Processors: %d\nHeader read time: %f\nData read time: %f\nCompute Slope time: %f\nWrite Slope time: %f\nResolve Flat time: %f\nWrite Flat time: %f\nTotal time: %f\n&quot;,</span>
<a name="l00274"></a>00274                 <span class="comment">//  size,headerRead,dataRead, computeSlope, writeSlope,computeFlat,writeFlat,total);</span>
<a name="l00275"></a>00275                 printf(<span class="stringliteral">&quot;Processors: %d\nRead time: %f\nCompute time: %f\nWrite time: %f\nTotal time: %f\n&quot;</span>,
<a name="l00276"></a>00276                     size,headerRead+dataRead, computeSlope+computeFlat, writeSlope+writeFlat,total);
<a name="l00277"></a>00277         }
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279     <span class="comment">//MPI_Barrier(MCW);</span>
<a name="l00280"></a>00280     MPI_Finalize();
<a name="l00281"></a>00281     <span class="keywordflow">return</span> 0;
<a name="l00282"></a>00282 }
<a name="l00283"></a>00283 <span class="keywordtype">void</span>   VSLOPE(<span class="keywordtype">float</span> E0,<span class="keywordtype">float</span> E1, <span class="keywordtype">float</span> E2,
<a name="l00284"></a>00284               <span class="keywordtype">float</span> D1,<span class="keywordtype">float</span> D2,<span class="keywordtype">float</span> DD,
<a name="l00285"></a>00285               <span class="keywordtype">float</span> *S,<span class="keywordtype">float</span> *A)
<a name="l00286"></a>00286 {
<a name="l00287"></a>00287     <span class="comment">//SUBROUTINE TO RETURN THE SLOPE AND ANGLE ASSOCIATED WITH A DEM PANEL </span>
<a name="l00288"></a>00288     <span class="keywordtype">float</span> S1,S2,AD;
<a name="l00289"></a>00289     <span class="keywordflow">if</span>(D1!=0)
<a name="l00290"></a>00290         S1=(E0-E1)/D1;
<a name="l00291"></a>00291     <span class="keywordflow">if</span>(D2!=0)
<a name="l00292"></a>00292         S2=(E1-E2)/D2;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294     <span class="keywordflow">if</span>(S2==0 &amp;&amp; S1==0) *A=0;
<a name="l00295"></a>00295     <span class="keywordflow">else</span>
<a name="l00296"></a>00296         *A= (float) atan2(S2,S1);
<a name="l00297"></a>00297     AD= (float) atan2(D2,D1);
<a name="l00298"></a>00298     <span class="keywordflow">if</span>(*A  &lt;   0.)
<a name="l00299"></a>00299     {
<a name="l00300"></a>00300         *A=0.;
<a name="l00301"></a>00301         *S=S1;
<a name="l00302"></a>00302     }
<a name="l00303"></a>00303     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*A &gt; AD)
<a name="l00304"></a>00304     {
<a name="l00305"></a>00305         *A=AD;
<a name="l00306"></a>00306         *S=(E0-E2)/DD;
<a name="l00307"></a>00307     }
<a name="l00308"></a>00308     <span class="keywordflow">else</span>
<a name="l00309"></a>00309         *S= (float) sqrt(S1*S1+S2*S2);
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 <span class="comment">// Sets only flowDir only where there is a positive slope</span>
<a name="l00312"></a>00312 <span class="comment">// Returns number of cells which are flat</span>
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="keywordtype">void</span>   SET2(<span class="keywordtype">int</span> I, <span class="keywordtype">int</span> J,<span class="keywordtype">float</span> *DXX,<span class="keywordtype">float</span> DD, tdpartition *elevDEM, tdpartition *flowDir, tdpartition *slope)
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316     <span class="keywordtype">double</span> dx = elevDEM-&gt;getdx();
<a name="l00317"></a>00317     <span class="keywordtype">double</span> dy = elevDEM-&gt;getdy();
<a name="l00318"></a>00318     <span class="keywordtype">float</span> SK[9];
<a name="l00319"></a>00319     <span class="keywordtype">float</span> ANGLE[9];
<a name="l00320"></a>00320     <span class="keywordtype">float</span> SMAX;
<a name="l00321"></a>00321     <span class="keywordtype">float</span> tempFloat;
<a name="l00322"></a>00322     <span class="keywordtype">int</span> K;
<a name="l00323"></a>00323     <span class="keywordtype">int</span> KD;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="keywordtype">int</span> ID1[]= {0,1,2,2,1,1,2,2,1 }; 
<a name="l00326"></a>00326     <span class="keywordtype">int</span> ID2[]= {0,2,1,1,2,2,1,1,2};
<a name="l00327"></a>00327     <span class="keywordtype">int</span> I1[] = {0,0,-1,-1,0,0,1,1,0 };
<a name="l00328"></a>00328     <span class="keywordtype">int</span> I2[] = {0,-1,-1,-1,-1,1,1,1,1};
<a name="l00329"></a>00329     <span class="keywordtype">int</span> J1[] = {0,1,0,0,-1,-1,0,0,1};
<a name="l00330"></a>00330     <span class="keywordtype">int</span> J2[] = {0,1,1,-1,-1,-1,-1,1,1};
<a name="l00331"></a>00331     <span class="keywordtype">float</span>  ANGC[]={0,0.,1.,1.,2.,2.,3.,3.,4.};
<a name="l00332"></a>00332     <span class="keywordtype">float</span>  ANGF[]={0,1.,-1.,1.,-1.,1.,-1.,1.,-1.};
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="keywordflow">for</span>(K=1; K&lt;=8; K++)
<a name="l00336"></a>00336     {
<a name="l00337"></a>00337         VSLOPE(
<a name="l00338"></a>00338             elevDEM-&gt;getData(J,I,tempFloat),<span class="comment">//felevg.d[J][I],</span>
<a name="l00339"></a>00339             elevDEM-&gt;getData(J+J1[K],I+I1[K],tempFloat),<span class="comment">//[felevg.d[J+J1[K]][I+I1[K]],</span>
<a name="l00340"></a>00340             elevDEM-&gt;getData(J+J2[K],I+I2[K],tempFloat),<span class="comment">//felevg.d[J+J2[K]][I+I2[K]],</span>
<a name="l00341"></a>00341             DXX[ID1[K]],
<a name="l00342"></a>00342             DXX[ID2[K]],
<a name="l00343"></a>00343             DD,
<a name="l00344"></a>00344             &amp;SK[K],
<a name="l00345"></a>00345             &amp;ANGLE[K]
<a name="l00346"></a>00346         );
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348     tempFloat = -1;
<a name="l00349"></a>00349     SMAX=0.;
<a name="l00350"></a>00350     KD=0;
<a name="l00351"></a>00351     flowDir-&gt;setData(J,I,tempFloat);  <span class="comment">//USE -1 TO INDICATE DIRECTION NOT YET SET </span>
<a name="l00352"></a>00352     <span class="keywordflow">for</span>(K=1; K&lt;=8; K++)
<a name="l00353"></a>00353     {
<a name="l00354"></a>00354         <span class="keywordflow">if</span>(SK[K] &gt;  SMAX)
<a name="l00355"></a>00355         {
<a name="l00356"></a>00356             SMAX=SK[K];
<a name="l00357"></a>00357             KD=K;
<a name="l00358"></a>00358         }
<a name="l00359"></a>00359     }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <span class="keywordflow">if</span>(KD  &gt; 0)
<a name="l00362"></a>00362     {
<a name="l00363"></a>00363         tempFloat = (float) (ANGC[KD]*(PI/2)+ANGF[KD]*ANGLE[KD]) ;
<a name="l00364"></a>00364         flowDir-&gt;setData(J,I,tempFloat);<span class="comment">//set to angle</span>
<a name="l00365"></a>00365     }
<a name="l00366"></a>00366     slope-&gt;setData(J,I,SMAX);
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 <span class="comment">//Overloaded SET2 for use in resolve flats when slope is no longer recorded.  Also uses artificial elevations and actual elevations</span>
<a name="l00369"></a>00369 <span class="keywordtype">void</span>   SET2(<span class="keywordtype">int</span> I, <span class="keywordtype">int</span> J,<span class="keywordtype">float</span> *DXX,<span class="keywordtype">float</span> DD, tdpartition *elevDEM, tdpartition *elev2, tdpartition *flowDir, tdpartition *dn)
<a name="l00370"></a>00370 {
<a name="l00371"></a>00371     <span class="keywordtype">float</span> SK[9];
<a name="l00372"></a>00372     <span class="keywordtype">float</span> ANGLE[9];
<a name="l00373"></a>00373     <span class="keywordtype">float</span> SMAX=0.0;
<a name="l00374"></a>00374     <span class="keywordtype">float</span> tempFloat;
<a name="l00375"></a>00375     <span class="keywordtype">short</span> tempShort, tempShort1, tempShort2;
<a name="l00376"></a>00376     <span class="keywordtype">int</span> K;
<a name="l00377"></a>00377     <span class="keywordtype">int</span> KD=0;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379     <span class="keywordtype">int</span> ID1[]= {0,1,2,2,1,1,2,2,1 }; 
<a name="l00380"></a>00380     <span class="keywordtype">int</span> ID2[]= {0,2,1,1,2,2,1,1,2};
<a name="l00381"></a>00381     <span class="keywordtype">int</span> I1[] = {0,0,-1,-1,0,0,1,1,0 };
<a name="l00382"></a>00382     <span class="keywordtype">int</span> I2[] = {0,-1,-1,-1,-1,1,1,1,1};
<a name="l00383"></a>00383     <span class="keywordtype">int</span> J1[] = {0,1,0,0,-1,-1,0,0,1};
<a name="l00384"></a>00384     <span class="keywordtype">int</span> J2[] = {0,1,1,-1,-1,-1,-1,1,1};
<a name="l00385"></a>00385     <span class="keywordtype">float</span>  ANGC[]={0,0.,1.,1.,2.,2.,3.,3.,4.};
<a name="l00386"></a>00386     <span class="keywordtype">float</span>  ANGF[]={0,1.,-1.,1.,-1.,1.,-1.,1.,-1.};
<a name="l00387"></a>00387     <span class="keywordtype">bool</span> diagOutFound=<span class="keyword">false</span>;
<a name="l00388"></a>00388 
<a name="l00389"></a>00389     <span class="keywordflow">for</span>(K=1; K&lt;=8; K++)
<a name="l00390"></a>00390     {
<a name="l00391"></a>00391         dn-&gt;getData(J+J1[K],I+I1[K],tempShort1);<span class="comment">//Check each square to see if it is in the flat.  If it is in the flat, use artifical elevations if not use real elevations</span>
<a name="l00392"></a>00392         dn-&gt;getData(J+J2[K],I+I2[K],tempShort2);<span class="comment">//dn = 0 if it is not in the flat.  dn = 1 if in flat.</span>
<a name="l00393"></a>00393         <span class="keywordflow">if</span>(tempShort1 &lt;= 0 &amp;&amp; tempShort2 &lt;= 0) { <span class="comment">//Both E1 and E2 are outside the flat get slope and angle</span>
<a name="l00394"></a>00394             <span class="keywordtype">float</span> a=elevDEM-&gt;getData(J,I,tempFloat);
<a name="l00395"></a>00395             <span class="keywordtype">float</span> b=elevDEM-&gt;getData(J+J1[K],I+I1[K],tempFloat);
<a name="l00396"></a>00396             <span class="keywordtype">float</span> c=elevDEM-&gt;getData(J+J2[K],I+I2[K],tempFloat);
<a name="l00397"></a>00397             VSLOPE(
<a name="l00398"></a>00398                 a,<span class="comment">//E0</span>
<a name="l00399"></a>00399                 b,<span class="comment">//E1</span>
<a name="l00400"></a>00400                 c,<span class="comment">//E2</span>
<a name="l00401"></a>00401                 DXX[ID1[K]],<span class="comment">//dx or dy depending on ID1</span>
<a name="l00402"></a>00402                 DXX[ID2[K]],<span class="comment">//dx or dy depending on ID2</span>
<a name="l00403"></a>00403                 DD,<span class="comment">//Hypotenuse</span>
<a name="l00404"></a>00404                 &amp;SK[K],<span class="comment">//Slope Returned</span>
<a name="l00405"></a>00405                 &amp;ANGLE[K]<span class="comment">//Angle Returned</span>
<a name="l00406"></a>00406             );
<a name="l00407"></a>00407             <span class="keywordflow">if</span>(SK[K]&gt;=0.0) <span class="comment">//  Found an outlet</span>
<a name="l00408"></a>00408             {
<a name="l00409"></a>00409                 <span class="keywordflow">if</span>(b&gt;a)  <span class="comment">// Outlet found had better be a diagonal, because it is not an edge</span>
<a name="l00410"></a>00410                 {
<a name="l00411"></a>00411                     <span class="keywordflow">if</span>(!diagOutFound)
<a name="l00412"></a>00412                     {
<a name="l00413"></a>00413                         diagOutFound=<span class="keyword">true</span>;
<a name="l00414"></a>00414                         KD=K;
<a name="l00415"></a>00415                     }
<a name="l00416"></a>00416                 }
<a name="l00417"></a>00417                 <span class="keywordflow">else</span>
<a name="l00418"></a>00418                 {    <span class="comment">//  Here it is an adjacent outlet</span>
<a name="l00419"></a>00419                     KD=K;
<a name="l00420"></a>00420                     <span class="keywordflow">break</span>;
<a name="l00421"></a>00421                 }
<a name="l00422"></a>00422             }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(tempShort1 &lt;= 0 &amp;&amp; tempShort2 &gt;0){<span class="comment">//E1 is outside of the flat and E2 is inside the flat. Use DEM elevations. tempShort2/E2 is in the artificial grid</span>
<a name="l00425"></a>00425             <span class="keywordtype">float</span> a=elevDEM-&gt;getData(J,I,tempFloat);
<a name="l00426"></a>00426             <span class="keywordtype">float</span> b=elevDEM-&gt;getData(J+J1[K],I+I1[K],tempFloat);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428             <span class="keywordflow">if</span>(a&gt;=b)
<a name="l00429"></a>00429             {
<a name="l00430"></a>00430                 ANGLE[K]=0.0;
<a name="l00431"></a>00431                 SK[K]=0.0;
<a name="l00432"></a>00432                 KD=K;
<a name="l00433"></a>00433                 <span class="keywordflow">break</span>;
<a name="l00434"></a>00434             }
<a name="l00435"></a>00435             <span class="keywordtype">short</span> a1=elev2-&gt;getData(J,I,tempShort);
<a name="l00436"></a>00436             <span class="keywordtype">short</span> c1=elev2-&gt;getData(J+J2[K],I+I2[K],tempShort);
<a name="l00437"></a>00437             <span class="keywordtype">short</span> b1=max(a1,c1);
<a name="l00438"></a>00438             VSLOPE(
<a name="l00439"></a>00439                 (<span class="keywordtype">float</span>)a1,<span class="comment">//felevg.d[J][I],</span>
<a name="l00440"></a>00440                 (<span class="keywordtype">float</span>)b1,<span class="comment">//[felevg.d[J+J1[K]][I+I1[K]],</span>
<a name="l00441"></a>00441                 (<span class="keywordtype">float</span>)c1,<span class="comment">//felevg.d[J+J2[K]][I+I2[K]],</span>
<a name="l00442"></a>00442                 DXX[ID1[K]],<span class="comment">//dx or dy</span>
<a name="l00443"></a>00443                 DXX[ID2[K]],<span class="comment">//dx or dy</span>
<a name="l00444"></a>00444                 DD,<span class="comment">//Hypotenuse</span>
<a name="l00445"></a>00445                 &amp;SK[K],<span class="comment">//Slope Returned</span>
<a name="l00446"></a>00446                 &amp;ANGLE[K]<span class="comment">//Angle Reutnred</span>
<a name="l00447"></a>00447             );
<a name="l00448"></a>00448             <span class="keywordflow">if</span>(SK[K]&gt;SMAX){
<a name="l00449"></a>00449                 SMAX=SK[K];
<a name="l00450"></a>00450                 KD=K;
<a name="l00451"></a>00451             }
<a name="l00452"></a>00452         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(tempShort1 &gt; 0 &amp;&amp; tempShort2 &lt;= 0){<span class="comment">//E2 is out side of the flat and E1 is inside the flat, use DEM elevations</span>
<a name="l00453"></a>00453             <span class="keywordtype">float</span> a=elevDEM-&gt;getData(J,I,tempFloat);
<a name="l00454"></a>00454             <span class="comment">//float b=elevDEM-&gt;getData(J+J1[K],I+I1[K],tempFloat);</span>
<a name="l00455"></a>00455             <span class="keywordtype">float</span> c=elevDEM-&gt;getData(J+J2[K],I+I2[K],tempFloat);
<a name="l00456"></a>00456             <span class="keywordflow">if</span>(a&gt;=c) 
<a name="l00457"></a>00457             {
<a name="l00458"></a>00458                 <span class="keywordflow">if</span>(!diagOutFound)
<a name="l00459"></a>00459                 {
<a name="l00460"></a>00460                     ANGLE[K]=(float) atan2(DXX[ID2[K]],DXX[ID1[K]]);
<a name="l00461"></a>00461                     SK[K]=0.0;
<a name="l00462"></a>00462                     KD=K;
<a name="l00463"></a>00463                     diagOutFound=<span class="keyword">true</span>;
<a name="l00464"></a>00464                 }
<a name="l00465"></a>00465             }
<a name="l00466"></a>00466             <span class="keywordflow">else</span>
<a name="l00467"></a>00467             {
<a name="l00468"></a>00468                 <span class="keywordtype">short</span> a1=elev2-&gt;getData(J,I,tempShort);
<a name="l00469"></a>00469                 <span class="keywordtype">short</span> b1=elev2-&gt;getData(J+J1[K],I+I1[K],tempShort);
<a name="l00470"></a>00470                 <span class="keywordtype">short</span> c1=max(a1,b1);
<a name="l00471"></a>00471                 VSLOPE(
<a name="l00472"></a>00472                     (<span class="keywordtype">float</span>)a1,<span class="comment">//felevg.d[J][I],</span>
<a name="l00473"></a>00473                     (<span class="keywordtype">float</span>)b1,<span class="comment">//[felevg.d[J+J1[K]][I+I1[K]],</span>
<a name="l00474"></a>00474                     (<span class="keywordtype">float</span>)c1,<span class="comment">//felevg.d[J+J2[K]][I+I2[K]],</span>
<a name="l00475"></a>00475                     DXX[ID1[K]],<span class="comment">//dx or dy</span>
<a name="l00476"></a>00476                     DXX[ID2[K]],<span class="comment">//dx or dy</span>
<a name="l00477"></a>00477                     DD,<span class="comment">//Hypotenuse</span>
<a name="l00478"></a>00478                     &amp;SK[K],<span class="comment">//Slope Returned</span>
<a name="l00479"></a>00479                     &amp;ANGLE[K]<span class="comment">//Angle Reutnred</span>
<a name="l00480"></a>00480                 );
<a name="l00481"></a>00481                 <span class="keywordflow">if</span>(SK[K]&gt;SMAX){
<a name="l00482"></a>00482                     SMAX=SK[K];
<a name="l00483"></a>00483                     KD=K;
<a name="l00484"></a>00484                 }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486             }
<a name="l00487"></a>00487         }<span class="keywordflow">else</span>{<span class="comment">//Both E1 and E2 are in the flat. Use artificial elevation to get slope and angle</span>
<a name="l00488"></a>00488             <span class="keywordtype">short</span> a, b,c;
<a name="l00489"></a>00489             a = elev2-&gt;getData(J,I,a);
<a name="l00490"></a>00490             b = elev2-&gt;getData(J+J1[K],I+I1[K],b);
<a name="l00491"></a>00491             c = elev2-&gt;getData(J+J2[K],I+I2[K],c);
<a name="l00492"></a>00492             VSLOPE(
<a name="l00493"></a>00493                 (<span class="keywordtype">float</span>)a,<span class="comment">//felevg.d[J][I],</span>
<a name="l00494"></a>00494                 (<span class="keywordtype">float</span>)b,<span class="comment">//[felevg.d[J+J1[K]][I+I1[K]],</span>
<a name="l00495"></a>00495                 (<span class="keywordtype">float</span>)c,<span class="comment">//felevg.d[J+J2[K]][I+I2[K]],</span>
<a name="l00496"></a>00496                 DXX[ID1[K]],<span class="comment">//dx or dy</span>
<a name="l00497"></a>00497                 DXX[ID2[K]],<span class="comment">//dx or dy</span>
<a name="l00498"></a>00498                 DD,<span class="comment">//Hypotenuse</span>
<a name="l00499"></a>00499                 &amp;SK[K],<span class="comment">//Slope Returned</span>
<a name="l00500"></a>00500                 &amp;ANGLE[K]<span class="comment">//Angle Reutnred</span>
<a name="l00501"></a>00501             );
<a name="l00502"></a>00502             <span class="keywordflow">if</span>(SK[K]&gt;SMAX){
<a name="l00503"></a>00503                 SMAX=SK[K];
<a name="l00504"></a>00504                 KD=K;
<a name="l00505"></a>00505             }
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507     }
<a name="l00508"></a>00508     <span class="comment">//USE -1 TO INDICATE DIRECTION NOT YET SET, </span>
<a name="l00509"></a>00509     <span class="comment">// but only for non pit grid cells.  Pits will have flowDir as no data</span>
<a name="l00510"></a>00510     <span class="keywordflow">if</span>(!flowDir-&gt;isNodata(J,I))
<a name="l00511"></a>00511     {
<a name="l00512"></a>00512         tempFloat = -1;
<a name="l00513"></a>00513         flowDir-&gt;setData(J,I,tempFloat);  
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516     <span class="keywordflow">if</span>(KD  &gt; 0 )<span class="comment">//We have a flow direction.  Calculate the Angle and save/write it.</span>
<a name="l00517"></a>00517     {
<a name="l00518"></a>00518         tempFloat = (float) (ANGC[KD]*(PI/2)+ANGF[KD]*ANGLE[KD]);<span class="comment">//Calculate the Angle</span>
<a name="l00519"></a>00519         <span class="keywordflow">if</span>(tempFloat &gt;= 0.0)<span class="comment">//Make sure the angle is positive</span>
<a name="l00520"></a>00520             flowDir-&gt;setData(J,I,tempFloat);<span class="comment">//set the angle in the flowPartition</span>
<a name="l00521"></a>00521     }
<a name="l00522"></a>00522 }
<a name="l00523"></a>00523 <span class="comment">//int setPosDirDinf(tdpartition *elevDEM, tdpartition *flowDir, tdpartition *slope, tdpartition *area, int useflowfile)</span>
<a name="l00524"></a>00524 <span class="keywordtype">long</span> setPosDirDinf(tdpartition *elevDEM, tdpartition *flowDir, tdpartition *slope, <span class="keywordtype">int</span> useflowfile) {
<a name="l00525"></a>00525     <span class="keywordtype">double</span> dx = elevDEM-&gt;getdx();
<a name="l00526"></a>00526     <span class="keywordtype">double</span> dy = elevDEM-&gt;getdy();
<a name="l00527"></a>00527     <span class="keywordtype">long</span> nx = elevDEM-&gt;getnx();
<a name="l00528"></a>00528     <span class="keywordtype">long</span> ny = elevDEM-&gt;getny();
<a name="l00529"></a>00529     <span class="keywordtype">float</span> tempFloat;
<a name="l00530"></a>00530     <span class="keywordtype">int</span> i,j,k,in,jn, con;
<a name="l00531"></a>00531     <span class="keywordtype">long</span> numFlat = 0;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <span class="comment">//Set direction factors</span>
<a name="l00534"></a>00534     <span class="keywordflow">for</span>( k=1; k&lt;= 8; k++ ){
<a name="l00535"></a>00535         fact[k] = (double) (1./sqrt(d1[k]*dx*d1[k]*dx + d2[k]*d2[k]*dy*dy));
<a name="l00536"></a>00536     }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538     tempFloat = 0;
<a name="l00539"></a>00539     <span class="keywordflow">for</span>( j = 0; j &lt; ny; j++) {
<a name="l00540"></a>00540         <span class="keywordflow">for</span>( i=0; i &lt; nx; i++ ) {
<a name="l00541"></a>00541             <span class="comment">//FlowDir is nodata if it is on the border OR elevDEM has no data</span>
<a name="l00542"></a>00542             <span class="keywordflow">if</span> ( elevDEM-&gt;isNodata(i,j) || !elevDEM-&gt;hasAccess(i-1,j) || !elevDEM-&gt;hasAccess(i+1,j) || 
<a name="l00543"></a>00543                         !elevDEM-&gt;hasAccess(i,j-1) || !elevDEM-&gt;hasAccess(i,j+1) )  {
<a name="l00544"></a>00544                 <span class="comment">//do nothing            </span>
<a name="l00545"></a>00545             }
<a name="l00546"></a>00546             <span class="keywordflow">else</span> { 
<a name="l00547"></a>00547                 <span class="comment">//Check if cell is &quot;contaminated&quot; (neighbors have no data)</span>
<a name="l00548"></a>00548                 <span class="comment">//  set flowDir to noData if contaminated</span>
<a name="l00549"></a>00549                 con = 0;
<a name="l00550"></a>00550                 <span class="keywordflow">for</span>( k=1;k&lt;=8 &amp;&amp; con != -1;k++) {
<a name="l00551"></a>00551                     in=i+d1[k];
<a name="l00552"></a>00552                     jn=j+d2[k];
<a name="l00553"></a>00553                     <span class="keywordflow">if</span>( elevDEM-&gt;isNodata(in,jn) ) con=-1;
<a name="l00554"></a>00554                 }
<a name="l00555"></a>00555                 <span class="keywordflow">if</span>( con == -1 ) flowDir-&gt;setToNodata(i,j);
<a name="l00556"></a>00556                 <span class="comment">//If cell is not contaminated,</span>
<a name="l00557"></a>00557                 <span class="keywordflow">else</span> {
<a name="l00558"></a>00558                     tempFloat= -1.;
<a name="l00559"></a>00559                     flowDir-&gt;setData(i,j,tempFloat);<span class="comment">//set to -1</span>
<a name="l00560"></a>00560                     
<a name="l00561"></a>00561                     <span class="keywordtype">float</span> DXX[3] = {0,dx,dy};<span class="comment">//tardemlib.cpp ln 1291</span>
<a name="l00562"></a>00562                     <span class="keywordtype">float</span> DD = sqrt(dx*dx+dy*dy);<span class="comment">//tardemlib.cpp ln 1293</span>
<a name="l00563"></a>00563                     SET2(j,i,DXX,DD, elevDEM,flowDir,slope);<span class="comment">//i=y in function form old code j is x switched on purpose</span>
<a name="l00564"></a>00564                     <span class="comment">//  Use SET2 from serial code here modified to get what it has as felevg.d from elevDEM partition</span>
<a name="l00565"></a>00565                     <span class="comment">//  Modify to return 0 if there is a 0 slope.  Modify SET2 to output flowDIR as no data (do nothing </span>
<a name="l00566"></a>00566                     <span class="comment">//  if verified initialization to nodata) and </span>
<a name="l00567"></a>00567                     <span class="comment">//  slope as 0 if a positive slope is not found</span>
<a name="l00568"></a>00568 
<a name="l00569"></a>00569                     <span class="comment">//setFlow( i,j, flowDir, elevDEM, area, useflowfile);</span>
<a name="l00570"></a>00570                     <span class="keywordflow">if</span>( flowDir-&gt;getData(i,j,tempFloat)==-1)
<a name="l00571"></a>00571                         numFlat++;
<a name="l00572"></a>00572                 }
<a name="l00573"></a>00573             }   
<a name="l00574"></a>00574         }
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576     <span class="keywordflow">return</span> numFlat;
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 <span class="comment">//Resolve flat cells according to Garbrecht and Martz</span>
<a name="l00580"></a>00580 <span class="keywordtype">long</span> resolveflats( tdpartition *elevDEM, tdpartition *flowDir, queue&lt;node&gt; *que, <span class="keywordtype">bool</span> &amp;first) {
<a name="l00581"></a>00581     elevDEM-&gt;share();
<a name="l00582"></a>00582     flowDir-&gt;share();
<a name="l00583"></a>00583     <span class="comment">//Header data</span>
<a name="l00584"></a>00584     <span class="keywordtype">long</span> totalx = elevDEM-&gt;gettotalx();
<a name="l00585"></a>00585     <span class="keywordtype">long</span> totaly = elevDEM-&gt;gettotaly();
<a name="l00586"></a>00586     <span class="keywordtype">long</span> nx = elevDEM-&gt;getnx();
<a name="l00587"></a>00587     <span class="keywordtype">long</span> ny = elevDEM-&gt;getny();
<a name="l00588"></a>00588     <span class="keywordtype">double</span> dx = elevDEM-&gt;getdx();
<a name="l00589"></a>00589     <span class="keywordtype">double</span> dy = elevDEM-&gt;getdy();
<a name="l00590"></a>00590 
<a name="l00591"></a>00591     <span class="keywordtype">int</span> rank;
<a name="l00592"></a>00592     MPI_Comm_rank(MCW,&amp;rank);
<a name="l00593"></a>00593 
<a name="l00594"></a>00594     <span class="keywordtype">long</span> i,j,k,in,jn;
<a name="l00595"></a>00595     <span class="keywordtype">bool</span> doNothing, done;
<a name="l00596"></a>00596     <span class="keywordtype">long</span> numFlat;
<a name="l00597"></a>00597     <span class="keywordtype">short</span> tempShort;
<a name="l00598"></a>00598     <span class="keywordtype">long</span> tempLong;
<a name="l00599"></a>00599     <span class="keywordtype">float</span> tempFloat;
<a name="l00600"></a>00600     <span class="keywordtype">long</span> numInc, numIncOld, numIncTotal;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     <span class="comment">//create and initialize temporary storage for Garbrecht and Martz</span>
<a name="l00603"></a>00603     tdpartition *elev2, *dn, *s;
<a name="l00604"></a>00604     elev2 = CreateNewPartition(SHORT_TYPE, totalx, totaly, dx, dy, 1);
<a name="l00605"></a>00605        <span class="comment">//  The assumption here is that resolving a flat does not increment a cell value </span>
<a name="l00606"></a>00606        <span class="comment">//  more than fits in a short</span>
<a name="l00607"></a>00607     dn = CreateNewPartition(SHORT_TYPE, totalx, totaly, dx, dy, 0);
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     node temp;
<a name="l00610"></a>00610     <span class="keywordtype">long</span> nflat=0, iflat;
<a name="l00611"></a>00611     <span class="comment">//  First time through add flat grid cells indicated by flowdir = 0 on to queue</span>
<a name="l00612"></a>00612     <span class="comment">//  The queue is retained for later passes so this only needs be done at beginning</span>
<a name="l00613"></a>00613     <span class="keywordflow">if</span>(first)
<a name="l00614"></a>00614     {
<a name="l00615"></a>00615         first=<span class="keyword">false</span>;
<a name="l00616"></a>00616         <span class="keywordflow">for</span>(j=0; j&lt;ny; j++){
<a name="l00617"></a>00617             <span class="keywordflow">for</span>(i=0; i&lt;nx; i++){
<a name="l00618"></a>00618                 <span class="keywordflow">if</span>(!flowDir-&gt;isNodata(i,j))
<a name="l00619"></a>00619                 {
<a name="l00620"></a>00620                     <span class="keywordflow">if</span>(flowDir-&gt;getData(i,j,tempFloat) &lt; 0.0)
<a name="l00621"></a>00621                     {
<a name="l00622"></a>00622                         temp.x=i; temp.y=j; que-&gt;push(temp);
<a name="l00623"></a>00623                     }
<a name="l00624"></a>00624                 }
<a name="l00625"></a>00625             }
<a name="l00626"></a>00626         }
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628     nflat=que-&gt;size();
<a name="l00629"></a>00629     dn-&gt;share();
<a name="l00630"></a>00630     elev2-&gt;share();
<a name="l00631"></a>00631 
<a name="l00632"></a>00632     <span class="comment">//incfall - drain toward lower ground</span>
<a name="l00633"></a>00633     <span class="comment">// Setting up while loop to calculate elev2 - the grid draining to lower ground</span>
<a name="l00634"></a>00634     done = <span class="keyword">false</span>;
<a name="l00635"></a>00635     numIncOld = -1; <span class="comment">//holds number of grid cells incremented on previous iteration </span>
<a name="l00636"></a>00636     <span class="comment">//  use -1 to force inequality on first pass through</span>
<a name="l00637"></a>00637     <span class="keywordtype">short</span> st = 1; <span class="comment">// used to indicate the level to which elev2 has been incremented </span>
<a name="l00638"></a>00638     <span class="keywordtype">float</span> elevDiff;
<a name="l00639"></a>00639     numIncTotal = 0; 
<a name="l00640"></a>00640     <span class="comment">//if(rank==0)</span>
<a name="l00641"></a>00641     <span class="comment">//{</span>
<a name="l00642"></a>00642     <span class="comment">//  fprintf(stderr,&quot;Draining flats towards lower adjacent terrain\n&quot;);  </span>
<a name="l00643"></a>00643     <span class="comment">//  fflush(stderr);</span>
<a name="l00644"></a>00644     <span class="comment">//}</span>
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <span class="keywordflow">while</span>(numIncTotal != numIncOld){  <span class="comment">// Continue to loop as long as grid cells are being incremented</span>
<a name="l00647"></a>00647         numInc = 0;
<a name="l00648"></a>00648         numIncOld = numIncTotal;
<a name="l00649"></a>00649         <span class="keywordflow">for</span>(iflat=0; iflat &lt; nflat; iflat++)
<a name="l00650"></a>00650         {
<a name="l00651"></a>00651             temp=que-&gt;front(); que-&gt;pop(); i=temp.x; j=temp.y; que-&gt;push(temp);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653                 doNothing=<span class="keyword">false</span>;
<a name="l00654"></a>00654                 <span class="keywordflow">for</span>(k=1; k&lt;=8; k++){
<a name="l00655"></a>00655                     <span class="keywordflow">if</span>(dontCross(k,i,j, flowDir)==0){
<a name="l00656"></a>00656                         jn = j + d2[k];
<a name="l00657"></a>00657                         in = i + d1[k];
<a name="l00658"></a>00658                     elevDiff = elevDEM-&gt;getData(i,j,tempFloat) - elevDEM-&gt;getData(in,jn,tempFloat);<span class="comment">// get elevations and elevation difference.</span>
<a name="l00659"></a>00659                     flowDir-&gt;getData(in,jn,tempFloat); <span class="comment">//get current flow direction...</span>
<a name="l00660"></a>00660                     <span class="keywordflow">if</span>(elevDiff &gt;= 0 &amp;&amp; tempFloat &gt;= 0.0) <span class="comment">//adjacent cell drains and is equal or lower in elevation so this is a low boundary</span>
<a name="l00661"></a>00661                         doNothing = <span class="keyword">true</span>;<span class="comment">//I don&#39;t have to do anything move on...</span>
<a name="l00662"></a>00662                     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(elevDiff == 0) <span class="comment">//if neighbor is in flat</span>
<a name="l00663"></a>00663                         <span class="keywordflow">if</span>(elev2-&gt;getData(in,jn,tempShort) &gt;=0 &amp;&amp; elev2-&gt;getData(in,jn,tempShort)&lt;st) <span class="comment">//neighbor is not being incremented</span>
<a name="l00664"></a>00664                             doNothing = <span class="keyword">true</span>;<span class="comment">//I don&#39;t have to do anything</span>
<a name="l00665"></a>00665                 }
<a name="l00666"></a>00666             }
<a name="l00667"></a>00667             <span class="keywordflow">if</span>(!doNothing){<span class="comment">//if I still have to do something...</span>
<a name="l00668"></a>00668                 elev2-&gt;addToData(i,j,<span class="keywordtype">short</span>(1));<span class="comment">//increment the s partition in this cell by one.</span>
<a name="l00669"></a>00669                     numInc++;
<a name="l00670"></a>00670                 }
<a name="l00671"></a>00671         }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673         elev2-&gt;share();
<a name="l00674"></a>00674         MPI_Allreduce(&amp;numInc, &amp;numIncTotal, 1, MPI_LONG, MPI_SUM, MCW);
<a name="l00675"></a>00675         <span class="comment">//  only break from while when total from all processes is no longer converging</span>
<a name="l00676"></a>00676         st++;
<a name="l00677"></a>00677         <span class="comment">//if(rank==0)</span>
<a name="l00678"></a>00678         <span class="comment">//{</span>
<a name="l00679"></a>00679         <span class="comment">//  fprintf(stderr,&quot;.&quot;);  // print a . at each pass to give an indication of progress</span>
<a name="l00680"></a>00680         <span class="comment">//  fflush(stderr);</span>
<a name="l00681"></a>00681         <span class="comment">//}</span>
<a name="l00682"></a>00682     }
<a name="l00683"></a>00683     <span class="keywordflow">if</span>(numIncTotal &gt; 0)  <span class="comment">// Not all grid cells were resolved - pits remain</span>
<a name="l00684"></a>00684         <span class="comment">// Remaining grid cells are unresolvable pits</span>
<a name="l00685"></a>00685     {
<a name="l00686"></a>00686 <span class="comment">//          There are pits remaining - set direction to no data</span>
<a name="l00687"></a>00687         <span class="keywordflow">for</span>(iflat=0; iflat &lt; nflat; iflat++)
<a name="l00688"></a>00688         {
<a name="l00689"></a>00689             temp=que-&gt;front(); que-&gt;pop(); i=temp.x; j=temp.y; que-&gt;push(temp);
<a name="l00690"></a>00690             doNothing=<span class="keyword">false</span>;
<a name="l00691"></a>00691                 <span class="keywordflow">for</span>(k=1; k&lt;=8; k++){
<a name="l00692"></a>00692                     <span class="keywordflow">if</span>(dontCross(k,i,j, flowDir)==0){
<a name="l00693"></a>00693                         jn = j + d2[k];
<a name="l00694"></a>00694                         in = i + d1[k];
<a name="l00695"></a>00695                         elevDiff = elevDEM-&gt;getData(i,j,tempFloat) - elevDEM-&gt;getData(in,jn,tempFloat);
<a name="l00696"></a>00696                         flowDir-&gt;getData(in,jn,tempFloat); 
<a name="l00697"></a>00697                         <span class="keywordflow">if</span>(elevDiff &gt;= 0 &amp;&amp; tempFloat &gt;= 0.) <span class="comment">//adjacent cell drains and is equal or lower in elevation so this is a low boundary</span>
<a name="l00698"></a>00698                                 doNothing = <span class="keyword">true</span>;
<a name="l00699"></a>00699                         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(elevDiff == 0) <span class="comment">//if neighbor is in flat</span>
<a name="l00700"></a>00700                             <span class="keywordflow">if</span>(elev2-&gt;getData(in,jn,tempShort) &gt;=0 &amp;&amp; elev2-&gt;getData(in,jn,tempShort)&lt;st) <span class="comment">//neighbor is not being incremented</span>
<a name="l00701"></a>00701                                 doNothing = <span class="keyword">true</span>;
<a name="l00702"></a>00702                     }
<a name="l00703"></a>00703                 }
<a name="l00704"></a>00704                 <span class="keywordflow">if</span>(!doNothing)
<a name="l00705"></a>00705                     flowDir-&gt;setData(i,j,MISSINGFLOAT);  <span class="comment">// mark pit</span>
<a name="l00706"></a>00706             }
<a name="l00707"></a>00707             flowDir-&gt;share();
<a name="l00708"></a>00708         
<a name="l00709"></a>00709         <span class="comment">//numIncOld = numIncTotal;</span>
<a name="l00710"></a>00710         <span class="comment">//int total = 0;</span>
<a name="l00711"></a>00711         <span class="comment">//  MPI_Allreduce(&amp;allDone, &amp;total, 1, MPI_INT, MPI_SUM, MCW);//see if anybody as done any work.</span>
<a name="l00712"></a>00712         <span class="comment">//if(total != 0)//Somebody did some work.</span>
<a name="l00713"></a>00713         <span class="comment">//  done = false;</span>
<a name="l00714"></a>00714         <span class="comment">//if(numIncOld == 0)//Nobody did any work! we are done.</span>
<a name="l00715"></a>00715         <span class="comment">//  done = true;</span>
<a name="l00716"></a>00716     }
<a name="l00717"></a>00717     <span class="comment">//  DGT moved from above - write directly into elev2</span>
<a name="l00718"></a>00718     s = CreateNewPartition(SHORT_TYPE, totalx, totaly, dx, dy, 0);  <span class="comment">//  Use 0 as no data to avoid need to initialize</span>
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     <span class="comment">//incrise - drain away from higher ground</span>
<a name="l00721"></a>00721     done = <span class="keyword">false</span>;
<a name="l00722"></a>00722     numIncOld = 0;
<a name="l00723"></a>00723     <span class="comment">//if(rank==0)</span>
<a name="l00724"></a>00724     <span class="comment">//{</span>
<a name="l00725"></a>00725     <span class="comment">//  fprintf(stderr,&quot;\nDraining flats away from higher adjacent terrain\n&quot;);  </span>
<a name="l00726"></a>00726     <span class="comment">//  fflush(stderr);</span>
<a name="l00727"></a>00727     <span class="comment">//}</span>
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     <span class="keywordflow">while</span>(!done){
<a name="l00730"></a>00730         numInc = 0;
<a name="l00731"></a>00731         <span class="keywordflow">for</span>(iflat=0; iflat &lt; nflat; iflat++)
<a name="l00732"></a>00732         {
<a name="l00733"></a>00733                 temp=que-&gt;front(); que-&gt;pop(); i=temp.x; j=temp.y; que-&gt;push(temp);
<a name="l00734"></a>00734                 <span class="keywordflow">for</span>(k=1; k&lt;=8; k++){
<a name="l00735"></a>00735                     jn = j + d2[k];
<a name="l00736"></a>00736                     in = i + d1[k];
<a name="l00737"></a>00737                     <span class="keywordflow">if</span>(elevDEM-&gt;getData(i,j,tempFloat) - elevDEM-&gt;getData(in,jn,tempFloat)&lt;0)   <span class="comment">//adjacent cell is higher</span>
<a name="l00738"></a>00738                         dn-&gt;setData(i,j,<span class="keywordtype">short</span>(1));<span class="comment">//cell in flat</span>
<a name="l00739"></a>00739                     <span class="keywordflow">if</span>(dn-&gt;getData(in,jn,tempShort)&gt;0 &amp;&amp; s-&gt;getData(in,jn,tempShort)&gt;0) <span class="comment">//adjacent cell has been marked already</span>
<a name="l00740"></a>00740                         dn-&gt;setData(i,j,<span class="keywordtype">short</span>(1));
<a name="l00741"></a>00741                 }
<a name="l00742"></a>00742         } 
<a name="l00743"></a>00743         dn-&gt;share();
<a name="l00744"></a>00744         <span class="keywordflow">for</span>(j=0; j&lt;ny; j++){
<a name="l00745"></a>00745             <span class="keywordflow">for</span>(i=0; i&lt;nx; i++){<span class="comment">//add dn values to s</span>
<a name="l00746"></a>00746                 dn-&gt;getData(i,j,tempShort);
<a name="l00747"></a>00747                 s-&gt;addToData(i,j,(tempShort&gt;0 ? <span class="keywordtype">short</span>(1) : <span class="keywordtype">short</span>(0)));
<a name="l00748"></a>00748                 <span class="keywordflow">if</span>(tempShort&gt;0) numInc++;
<a name="l00749"></a>00749             }
<a name="l00750"></a>00750         }
<a name="l00751"></a>00751         s-&gt;share();
<a name="l00752"></a>00752         dn-&gt;share();
<a name="l00753"></a>00753         MPI_Allreduce(&amp;numInc, &amp;numIncTotal, 1, MPI_LONG, MPI_SUM, MCW);
<a name="l00754"></a>00754         <span class="keywordflow">if</span>(numIncTotal==numIncOld) done=<span class="keyword">true</span>;
<a name="l00755"></a>00755         numIncOld = numIncTotal;
<a name="l00756"></a>00756         <span class="comment">//if(rank==0)</span>
<a name="l00757"></a>00757         <span class="comment">//{</span>
<a name="l00758"></a>00758         <span class="comment">//  fprintf(stderr,&quot;.&quot;);  // print a . at each pass to give an indication of progress</span>
<a name="l00759"></a>00759         <span class="comment">//  fflush(stderr);</span>
<a name="l00760"></a>00760         <span class="comment">//}</span>
<a name="l00761"></a>00761     }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     <span class="keywordflow">for</span>(iflat=0; iflat &lt; nflat; iflat++)
<a name="l00764"></a>00764     {
<a name="l00765"></a>00765             temp=que-&gt;front(); que-&gt;pop(); i=temp.x; j=temp.y; que-&gt;push(temp);
<a name="l00766"></a>00766 
<a name="l00767"></a>00767             elev2-&gt;addToData(i,j,s-&gt;getData(i,j,tempShort));
<a name="l00768"></a>00768     }
<a name="l00769"></a>00769     elev2-&gt;share();
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     <span class="keywordtype">long</span> localStillFlat = 0;
<a name="l00772"></a>00772     <span class="keywordtype">long</span> totalStillFlat = 0;
<a name="l00773"></a>00773 
<a name="l00774"></a>00774     <span class="keywordtype">float</span> DXX[3] = {0,dx,dy};<span class="comment">//tardemlib.cpp ln 1291</span>
<a name="l00775"></a>00775     <span class="keywordtype">float</span> DD = sqrt(dx*dx+dy*dy);<span class="comment">//tardemlib.cpp ln 1293</span>
<a name="l00776"></a>00776     <span class="comment">//if(rank==0)</span>
<a name="l00777"></a>00777     <span class="comment">//{</span>
<a name="l00778"></a>00778     <span class="comment">//  fprintf(stderr,&quot;\nSetting directions\n&quot;);  </span>
<a name="l00779"></a>00779     <span class="comment">//  fflush(stderr);</span>
<a name="l00780"></a>00780     <span class="comment">//}</span>
<a name="l00781"></a>00781     <span class="keywordflow">for</span>(iflat=0; iflat &lt; nflat; iflat++)
<a name="l00782"></a>00782     {
<a name="l00783"></a>00783             temp=que-&gt;front(); que-&gt;pop(); i=temp.x; j=temp.y; <span class="comment">//  Do not push que on this last one - so que is empty at end</span>
<a name="l00784"></a>00784                 <span class="comment">//  The logic here was to replace SETFLOW2 from D8 with SET2 so that it computes a DINF flow </span>
<a name="l00785"></a>00785                 <span class="comment">//  direction based on the artificial elevations </span>
<a name="l00786"></a>00786             SET2(j,i,DXX,DD,elevDEM,elev2,flowDir,dn);  <span class="comment">//use new elevations to calculate flowDir.  </span>
<a name="l00787"></a>00787             <span class="keywordflow">if</span>(!flowDir-&gt;isNodata(i,j)&amp;&amp; flowDir-&gt;getData(i,j,tempFloat)&lt; 0.) <span class="comment">//this is still a flat</span>
<a name="l00788"></a>00788             {
<a name="l00789"></a>00789                 que-&gt;push(temp);
<a name="l00790"></a>00790                 localStillFlat++;
<a name="l00791"></a>00791             }
<a name="l00792"></a>00792     }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794     MPI_Allreduce(&amp;localStillFlat, &amp;totalStillFlat, 1, MPI_LONG, MPI_SUM, MCW);
<a name="l00795"></a>00795     <span class="keywordflow">if</span>(totalStillFlat &gt;0)  <span class="comment">//  We will have to iterate again so overwrite original elevation with the modified ones and hope for the best</span>
<a name="l00796"></a>00796     {
<a name="l00797"></a>00797         <span class="keywordflow">for</span>(j=0; j&lt;ny; j++)
<a name="l00798"></a>00798             <span class="keywordflow">for</span>(i=0; i&lt;nx; i++){
<a name="l00799"></a>00799                 elevDEM-&gt;setData(i,j,(<span class="keywordtype">float</span>)elev2-&gt;getData(i,j,tempShort));<span class="comment">//set/add change jjn friday</span>
<a name="l00800"></a>00800             }
<a name="l00801"></a>00801     }
<a name="l00802"></a>00802     <span class="keyword">delete</span> elev2;  <span class="comment">//  to avoid memory leaks</span>
<a name="l00803"></a>00803     <span class="keyword">delete</span> dn;
<a name="l00804"></a>00804     <span class="keyword">delete</span> s;
<a name="l00805"></a>00805     <span class="keywordflow">return</span> totalStillFlat;
<a name="l00806"></a>00806 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 13 2016 06:05:22 for SEIMS-2016 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
