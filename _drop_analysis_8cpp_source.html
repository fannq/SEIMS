<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SEIMS-2016: preprocess/cpp_src/TauDEM/DropAnalysis.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SEIMS-2016
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Spatially Explicit Integrated Modeling System</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">preprocess/cpp_src/TauDEM/DropAnalysis.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*  DropAnalysis function that applies a series of thresholds (determined from the input parameters) </span>
<a name="l00002"></a>00002 <span class="comment">  to the input ssa grid and outputs in the drp.txt file the stream drop statistics table.  </span>
<a name="l00003"></a>00003 <span class="comment">  </span>
<a name="l00004"></a>00004 <span class="comment">  David Tarboton, Dan Watson</span>
<a name="l00005"></a>00005 <span class="comment">  Utah State University  </span>
<a name="l00006"></a>00006 <span class="comment">  May 23, 2010 </span>
<a name="l00007"></a>00007 <span class="comment">  </span>
<a name="l00008"></a>00008 <span class="comment">*/</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="comment">/*  Copyright (C) 2010  David Tarboton, Utah State University</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">This program is free software; you can redistribute it and/or</span>
<a name="l00013"></a>00013 <span class="comment">modify it under the terms of the GNU General Public License </span>
<a name="l00014"></a>00014 <span class="comment">version 2, 1991 as published by the Free Software Foundation.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">This program is distributed in the hope that it will be useful,</span>
<a name="l00017"></a>00017 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00018"></a>00018 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00019"></a>00019 <span class="comment">GNU General Public License for more details.</span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">A copy of the full GNU General Public License is included in file </span>
<a name="l00022"></a>00022 <span class="comment">gpl.html. This is also available at:</span>
<a name="l00023"></a>00023 <span class="comment">http://www.gnu.org/copyleft/gpl.html</span>
<a name="l00024"></a>00024 <span class="comment">or from:</span>
<a name="l00025"></a>00025 <span class="comment">The Free Software Foundation, Inc., 59 Temple Place - Suite 330, </span>
<a name="l00026"></a>00026 <span class="comment">Boston, MA  02111-1307, USA.</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">If you wish to use or incorporate this program (or parts of it) into </span>
<a name="l00029"></a>00029 <span class="comment">other software that does not meet the GNU General Public License </span>
<a name="l00030"></a>00030 <span class="comment">conditions contact the author to request permission.</span>
<a name="l00031"></a>00031 <span class="comment">David G. Tarboton  </span>
<a name="l00032"></a>00032 <span class="comment">Utah State University </span>
<a name="l00033"></a>00033 <span class="comment">8200 Old Main Hill </span>
<a name="l00034"></a>00034 <span class="comment">Logan, UT 84322-8200 </span>
<a name="l00035"></a>00035 <span class="comment">USA </span>
<a name="l00036"></a>00036 <span class="comment">http://www.engineering.usu.edu/dtarb/ </span>
<a name="l00037"></a>00037 <span class="comment">email:  dtarb@usu.edu </span>
<a name="l00038"></a>00038 <span class="comment">*/</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">//  This software is distributed from http://hydrology.usu.edu/taudem/</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;commonLib.h&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;linearpart.h&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;createpart.h&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;tiffIO.h&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;DropAnalysis.h&quot;</span>
<a name="l00053"></a>00053 <span class="keyword">using namespace </span>std;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">//does the appropriate updates when a junction is found</span>
<a name="l00056"></a>00056 <span class="keywordtype">void</span> updateAtJunction(<span class="keywordtype">short</span> oOut,<span class="keywordtype">long</span> i, <span class="keywordtype">long</span> ni,<span class="keywordtype">long</span> j, <span class="keywordtype">long</span> nj, <span class="keywordtype">long</span> nx, <span class="keywordtype">long</span> ny, tdpartition *dirData,
<a name="l00057"></a>00057                       tdpartition *orderOut, tdpartition *elevOut, 
<a name="l00058"></a>00058                       tdpartition *elevData, <span class="keywordtype">bool</span> &amp;newstream,
<a name="l00059"></a>00059                       <span class="keywordtype">float</span> &amp;s1,<span class="keywordtype">float</span> &amp;s1sq,<span class="keywordtype">float</span> &amp;s2,<span class="keywordtype">float</span> &amp;s2sq,<span class="keywordtype">long</span> &amp;n1,<span class="keywordtype">long</span> &amp;n2){
<a name="l00060"></a>00060     <span class="keywordtype">short</span> o;
<a name="l00061"></a>00061     <span class="keywordtype">float</span> drop;
<a name="l00062"></a>00062     <span class="keywordtype">float</span> e;
<a name="l00063"></a>00063     <span class="comment">//simply return if at partition side edge</span>
<a name="l00064"></a>00064     <span class="comment">//TODO use either hasaccess or isinpartition functions</span>
<a name="l00065"></a>00065     <span class="comment">//if(ni&lt;=0||ni&gt;=nx-1||j&lt;0||j&gt;ny)return;</span>
<a name="l00066"></a>00066     <span class="keywordflow">if</span>(!orderOut-&gt;hasAccess(ni,nj))<span class="keywordflow">return</span>;
<a name="l00067"></a>00067     <span class="comment">//simply return if ni,nj doesn&#39;t point to i,j</span>
<a name="l00068"></a>00068     <span class="keywordflow">if</span>(!pointsToMe(i,j,ni,nj,dirData) || orderOut-&gt;isNodata(ni,nj))<span class="keywordflow">return</span>;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070     <span class="comment">//get the order of the pointing cell</span>
<a name="l00071"></a>00071     o=orderOut-&gt;getData(ni,nj,o);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     <span class="comment">// no updates if an order 0 cell points at this cell</span>
<a name="l00074"></a>00074     <span class="comment">// if(o&lt;=0)return;  //DGT should never happen</span>
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     <span class="comment">// if the order increases here, there is an end to the stream segment</span>
<a name="l00077"></a>00077     <span class="keywordflow">if</span>(o&lt;oOut){
<a name="l00078"></a>00078         <span class="comment">//  This is the terminus of a stream so accumulate drops</span>
<a name="l00079"></a>00079         drop = elevOut-&gt;getData(ni,nj,e)-elevData-&gt;getData(i,j,e);
<a name="l00080"></a>00080         <span class="comment">// the update for the order1 segments is handled differently...</span>
<a name="l00081"></a>00081         <span class="keywordflow">if</span>(o==1){
<a name="l00082"></a>00082             s1= s1+drop;
<a name="l00083"></a>00083             s1sq= s1sq+drop*drop;
<a name="l00084"></a>00084             n1= n1+1;
<a name="l00085"></a>00085             <span class="comment">//printf(&quot;Junction: %d %d %d %d\n&quot;,i,j,ni,nj);</span>
<a name="l00086"></a>00086             <span class="comment">//fflush(stdout);</span>
<a name="l00087"></a>00087         <span class="comment">// ... from the rest of the segments</span>
<a name="l00088"></a>00088         }<span class="keywordflow">else</span>{
<a name="l00089"></a>00089             s2= s2+drop;
<a name="l00090"></a>00090             s2sq= s2sq+drop*drop;
<a name="l00091"></a>00091             n2= n2+1;
<a name="l00092"></a>00092         }
<a name="l00093"></a>00093     }<span class="keywordflow">else</span>{
<a name="l00094"></a>00094         <span class="comment">//  This is the continuation of a main stream to pass elevOut on down</span>
<a name="l00095"></a>00095         elevOut-&gt;setData(i,j,elevOut-&gt;getData(ni,nj,e));
<a name="l00096"></a>00096         newstream=<span class="keyword">false</span>;
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">//find the orderOut of a cell based on all the incoming orders</span>
<a name="l00102"></a>00102 <span class="keywordtype">short</span> newOrder(<span class="keywordtype">short</span> nOrder[8], <span class="keywordtype">bool</span> &amp;junction, <span class="keywordtype">bool</span> &amp;source){
<a name="l00103"></a>00103     <span class="keywordtype">short</span> i,j,temp;
<a name="l00104"></a>00104     <span class="keywordtype">short</span> oOut=1;  <span class="comment">//  initialize to 1</span>
<a name="l00105"></a>00105     <span class="keywordtype">short</span> ordermax=0;
<a name="l00106"></a>00106     <span class="keywordtype">short</span> count=0;
<a name="l00107"></a>00107     junction=<span class="keyword">false</span>;
<a name="l00108"></a>00108     source=<span class="keyword">true</span>;
<a name="l00109"></a>00109     <span class="comment">//  DGT revised logic to be a bit more efficient avoiding sort (and following old code)</span>
<a name="l00110"></a>00110     <span class="keywordflow">for</span>(i=0; i&lt;8; i++)
<a name="l00111"></a>00111     {
<a name="l00112"></a>00112         <span class="keywordflow">if</span>(nOrder[i]&gt;0)  <span class="comment">// Here an inflowing stream</span>
<a name="l00113"></a>00113         {
<a name="l00114"></a>00114             count=count+1;
<a name="l00115"></a>00115             source=<span class="keyword">false</span>;
<a name="l00116"></a>00116             <span class="keywordflow">if</span>(count == 1) <span class="comment">//  First inflowing stream</span>
<a name="l00117"></a>00117             {
<a name="l00118"></a>00118                 oOut=nOrder[i];
<a name="l00119"></a>00119                 ordermax=nOrder[i];
<a name="l00120"></a>00120             }<span class="keywordflow">else</span>  <span class="comment">// Here count is &gt; 1</span>
<a name="l00121"></a>00121             {
<a name="l00122"></a>00122                 <span class="keywordflow">if</span>(nOrder[i]&gt; oOut)
<a name="l00123"></a>00123                 {
<a name="l00124"></a>00124                     ordermax = nOrder[i];
<a name="l00125"></a>00125                     oOut=nOrder[i];
<a name="l00126"></a>00126                 }
<a name="l00127"></a>00127                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nOrder[i]==oOut) oOut=ordermax+1;
<a name="l00128"></a>00128                 <span class="comment">//  This logic to ensure that order is max of highest in or second highest in +1</span>
<a name="l00129"></a>00129                 junction=<span class="keyword">true</span>;
<a name="l00130"></a>00130             }
<a name="l00131"></a>00131         }
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133     <span class="comment">//sort the two largest to the bottom of the list</span>
<a name="l00134"></a>00134     <span class="comment">/*  Dan&#39;s logic DGT skipped - the sort is not necessary </span>
<a name="l00135"></a>00135 <span class="comment">    for(i=0;i&lt;2;++i){</span>
<a name="l00136"></a>00136 <span class="comment">        for(j=0;j&lt;7;++j){</span>
<a name="l00137"></a>00137 <span class="comment">            if(nOrder[j]&gt;nOrder[j+1]){</span>
<a name="l00138"></a>00138 <span class="comment">                temp=nOrder[j];</span>
<a name="l00139"></a>00139 <span class="comment">                nOrder[j]=nOrder[j+1];</span>
<a name="l00140"></a>00140 <span class="comment">                nOrder[j+1]=temp;</span>
<a name="l00141"></a>00141 <span class="comment">            }</span>
<a name="l00142"></a>00142 <span class="comment">        }</span>
<a name="l00143"></a>00143 <span class="comment">    }</span>
<a name="l00144"></a>00144 <span class="comment">    junction = false;</span>
<a name="l00145"></a>00145 <span class="comment">    if(nOrder[6]&gt;0)  // if 2 or more paths merge then the order of the 6th entry will be 1 or higher so flag as a junction</span>
<a name="l00146"></a>00146 <span class="comment">        junction=true;</span>
<a name="l00147"></a>00147 <span class="comment">    //if the last two have the same order, there is a junction, so bump the order</span>
<a name="l00148"></a>00148 <span class="comment">    if(nOrder[6]==nOrder[7]){</span>
<a name="l00149"></a>00149 <span class="comment">        //junction=true;</span>
<a name="l00150"></a>00150 <span class="comment">        oOut=nOrder[7]+1;</span>
<a name="l00151"></a>00151 <span class="comment">    }else{</span>
<a name="l00152"></a>00152 <span class="comment">        oOut=nOrder[7];</span>
<a name="l00153"></a>00153 <span class="comment">    }  */</span>
<a name="l00154"></a>00154     <span class="keywordflow">return</span> oOut;
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keywordtype">int</span> dropan(<span class="keywordtype">char</span> *areafile, <span class="keywordtype">char</span> *dirfile, <span class="keywordtype">char</span> *elevfile, <span class="keywordtype">char</span> *ssafile, <span class="keywordtype">char</span> *dropfile,
<a name="l00162"></a>00162                            <span class="keywordtype">char</span> *outletfile, <span class="keywordtype">float</span> threshmin, <span class="keywordtype">float</span> threshmax, <span class="keywordtype">int</span> nthresh, <span class="keywordtype">int</span> steptype,
<a name="l00163"></a>00163                            <span class="keywordtype">float</span> *threshopt)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     <span class="comment">// MPI Init section</span>
<a name="l00167"></a>00167     MPI_Init(NULL,NULL);{
<a name="l00168"></a>00168     <span class="keywordtype">int</span> rank,size;
<a name="l00169"></a>00169     MPI_Comm_rank(MCW,&amp;rank);
<a name="l00170"></a>00170     MPI_Comm_size(MCW,&amp;size);
<a name="l00171"></a>00171     <span class="keywordflow">if</span>(rank==0)
<a name="l00172"></a>00172     {
<a name="l00173"></a>00173         printf(<span class="stringliteral">&quot;DropAnalysis version %s\n&quot;</span>,TDVERSION);
<a name="l00174"></a>00174         fflush(stdout);
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     <span class="comment">// *** initialize thresholds array and directions table</span>
<a name="l00178"></a>00178     <span class="keywordtype">float</span> s1,s2,s1sq,s2sq;
<a name="l00179"></a>00179     <span class="keywordtype">float</span> tempFloat;
<a name="l00180"></a>00180     <span class="keywordtype">short</span> tempShort;
<a name="l00181"></a>00181     <span class="keywordtype">bool</span> finished;
<a name="l00182"></a>00182     <span class="keywordtype">long</span> n1,n2;
<a name="l00183"></a>00183     <span class="keywordtype">bool</span> optnotset=<span class="keyword">true</span>;
<a name="l00184"></a>00184     
<a name="l00185"></a>00185     <span class="keywordtype">double</span> begint = MPI_Wtime();
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="comment">//  *** initiate fssada grid partition from ssafile</span>
<a name="l00188"></a>00188     tiffIO ssa(ssafile, FLOAT_TYPE);  <span class="comment">// DGT changed from short type</span>
<a name="l00189"></a>00189     <span class="keywordtype">long</span> ssaTotalX = ssa.getTotalX();
<a name="l00190"></a>00190     <span class="keywordtype">long</span> ssaTotalY = ssa.getTotalY();
<a name="l00191"></a>00191     <span class="keywordtype">double</span> ssadx = ssa.getdx();
<a name="l00192"></a>00192     <span class="keywordtype">double</span> ssady = ssa.getdy();
<a name="l00193"></a>00193     <span class="comment">//if(rank==0)</span>
<a name="l00194"></a>00194     <span class="comment">//  {</span>
<a name="l00195"></a>00195     <span class="comment">//      float timeestimate=(2e-7*ssaTotalX*ssaTotalY*nthresh/pow((double) size,0.65))/60+1;  // Time estimate in minutes</span>
<a name="l00196"></a>00196     <span class="comment">//      fprintf(stderr,&quot;This run may take on the order of %.0f minutes to complete.\n&quot;,timeestimate);</span>
<a name="l00197"></a>00197     <span class="comment">//      fprintf(stderr,&quot;This estimate is very approximate. \nRun time is highly uncertain as it depends on the complexity of the input data \nand speed and memory of the computer. This estimate is based on our testing on \na dual quad core Dell Xeon E5405 2.0GHz PC with 16GB RAM.\n&quot;);</span>
<a name="l00198"></a>00198     <span class="comment">//      fflush(stderr);</span>
<a name="l00199"></a>00199     <span class="comment">//  }</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 
<a name="l00202"></a>00202     <span class="comment">//Create partition and read data</span>
<a name="l00203"></a>00203     tdpartition *ssaData;
<a name="l00204"></a>00204     ssaData = CreateNewPartition(ssa.getDatatype(), ssaTotalX, ssaTotalY, ssadx, ssady, ssa.getNodata());
<a name="l00205"></a>00205     <span class="keywordtype">int</span> ssanx = ssaData-&gt;getnx();
<a name="l00206"></a>00206     <span class="keywordtype">int</span> ssany = ssaData-&gt;getny();
<a name="l00207"></a>00207     <span class="keywordtype">int</span> ssaxstart, ssaystart;  
<a name="l00208"></a>00208     ssaData-&gt;localToGlobal(0, 0, ssaxstart, ssaystart);  
<a name="l00209"></a>00209     ssa.read((<span class="keywordtype">long</span>)ssaxstart, (<span class="keywordtype">long</span>)ssaystart, (<span class="keywordtype">long</span>)ssany, (<span class="keywordtype">long</span>)ssanx, ssaData-&gt;getGridPointer());
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <span class="keywordtype">float</span> ssadiag;
<a name="l00212"></a>00212     ssadiag=sqrt((ssadx*ssadx)+(ssady*ssady));
<a name="l00213"></a>00213             
<a name="l00214"></a>00214     <span class="comment">//  *** initiate sdir grid partition from dirfile</span>
<a name="l00215"></a>00215     <span class="comment">//printf(&quot;file %s\n&quot;,dirfile);</span>
<a name="l00216"></a>00216     tiffIO dir(dirfile, SHORT_TYPE);
<a name="l00217"></a>00217     <span class="keywordtype">long</span> dirTotalX = dir.getTotalX();
<a name="l00218"></a>00218     <span class="keywordtype">long</span> dirTotalY = dir.getTotalY();
<a name="l00219"></a>00219     <span class="keywordtype">double</span> dirdx = dir.getdx();
<a name="l00220"></a>00220     <span class="keywordtype">double</span> dirdy = dir.getdy();
<a name="l00221"></a>00221     <span class="comment">//printf(&quot;header read\n&quot;);</span>
<a name="l00222"></a>00222     <span class="comment">//short ndv=*(short*) dir.getNodata();</span>
<a name="l00223"></a>00223     <span class="comment">//printf(&quot;No data value %d&quot;,ndv);</span>
<a name="l00224"></a>00224     <span class="comment">//Create partition and read data</span>
<a name="l00225"></a>00225     tdpartition *dirData;
<a name="l00226"></a>00226     dirData = CreateNewPartition(dir.getDatatype(), dirTotalX, dirTotalY, dirdx, dirdy, dir.getNodata());
<a name="l00227"></a>00227     <span class="keywordtype">int</span> dirnx = dirData-&gt;getnx();
<a name="l00228"></a>00228     <span class="keywordtype">int</span> dirny = dirData-&gt;getny();
<a name="l00229"></a>00229     <span class="keywordtype">int</span> dirxstart, dirystart; 
<a name="l00230"></a>00230     dirData-&gt;localToGlobal(0, 0, dirxstart, dirystart);
<a name="l00231"></a>00231     dir.read((<span class="keywordtype">long</span>)dirxstart, (<span class="keywordtype">long</span>)dirystart, (<span class="keywordtype">long</span>)dirny, (<span class="keywordtype">long</span>)dirnx, dirData-&gt;getGridPointer());
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 
<a name="l00234"></a>00234     <span class="comment">//  *** initiate Aread8 grid partition from areafile //DGT changed to float to be flexible for large areas and also to include cell size (at cost of some imprecision)</span>
<a name="l00235"></a>00235     tiffIO area(areafile, FLOAT_TYPE);
<a name="l00236"></a>00236     <span class="keywordtype">long</span> areaTotalX = area.getTotalX();
<a name="l00237"></a>00237     <span class="keywordtype">long</span> areaTotalY = area.getTotalY();
<a name="l00238"></a>00238     <span class="keywordtype">double</span> areadx = area.getdx();
<a name="l00239"></a>00239     <span class="keywordtype">double</span> aready = area.getdy();
<a name="l00240"></a>00240     <span class="comment">//Create partition and read data</span>
<a name="l00241"></a>00241     tdpartition *areaData;
<a name="l00242"></a>00242     areaData = CreateNewPartition(area.getDatatype(), areaTotalX, areaTotalY, areadx, aready, area.getNodata());
<a name="l00243"></a>00243     <span class="keywordtype">int</span> areanx = areaData-&gt;getnx();
<a name="l00244"></a>00244     <span class="keywordtype">int</span> areany = areaData-&gt;getny();
<a name="l00245"></a>00245     <span class="keywordtype">int</span> areaxstart, areaystart;
<a name="l00246"></a>00246     areaData-&gt;localToGlobal(0, 0, areaxstart, areaystart);
<a name="l00247"></a>00247     area.read(areaxstart, areaystart, areany, areanx, areaData-&gt;getGridPointer());
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 
<a name="l00250"></a>00250     <span class="keywordflow">if</span>(!dir.compareTiff(ssa)){
<a name="l00251"></a>00251         printf(<span class="stringliteral">&quot;dir and ssa files not the same size. Exiting \n&quot;</span>);
<a name="l00252"></a>00252         MPI_Abort(MCW,4);
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254     <span class="keywordflow">if</span>(!ssa.compareTiff(area)){
<a name="l00255"></a>00255         printf(<span class="stringliteral">&quot;ssa and area files not the same size. Exiting \n&quot;</span>);
<a name="l00256"></a>00256         MPI_Abort(MCW,4);
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="comment">//  Read outlets</span>
<a name="l00260"></a>00260     <span class="keywordtype">int</span> nxy;
<a name="l00261"></a>00261     <span class="keywordtype">double</span> *xnode, *ynode;
<a name="l00262"></a>00262     <span class="keywordtype">int</span> i,j;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     <span class="keywordflow">if</span>(rank==0){
<a name="l00265"></a>00265         <span class="keywordflow">if</span>(readoutlets(outletfile, &amp;nxy, xnode, ynode)==0){
<a name="l00266"></a>00266             MPI_Bcast(&amp;nxy, 1, MPI_INT, 0, MCW);
<a name="l00267"></a>00267             MPI_Bcast(xnode, nxy, MPI_DOUBLE, 0, MCW);
<a name="l00268"></a>00268             MPI_Bcast(ynode, nxy, MPI_DOUBLE, 0, MCW);
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270         <span class="keywordflow">else</span> {
<a name="l00271"></a>00271             printf(<span class="stringliteral">&quot;Error opening shapefile. Exiting \n&quot;</span>);
<a name="l00272"></a>00272             MPI_Abort(MCW,5);
<a name="l00273"></a>00273         }
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275     <span class="keywordflow">else</span> {
<a name="l00276"></a>00276         MPI_Bcast(&amp;nxy, 1, MPI_INT, 0, MCW);
<a name="l00277"></a>00277         xnode = <span class="keyword">new</span> <span class="keywordtype">double</span>[nxy];
<a name="l00278"></a>00278         ynode = <span class="keyword">new</span> <span class="keywordtype">double</span>[nxy];
<a name="l00279"></a>00279         MPI_Bcast(xnode, nxy, MPI_DOUBLE, 0, MCW);
<a name="l00280"></a>00280         MPI_Bcast(ynode, nxy, MPI_DOUBLE, 0, MCW);
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="comment">// ***  sum AreaD8 at each terminal outlet this gives total area of </span>
<a name="l00284"></a>00284     <span class="comment">// ***  the domain being processed</span>
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="keywordtype">float</span> totalAreaProcessed; <span class="comment">//total area of the domain being processed</span>
<a name="l00287"></a>00287     <span class="keywordtype">float</span> ta;  <span class="comment">//  DGT changed from long to float for consistency with total area processed</span>
<a name="l00288"></a>00288     <span class="keywordtype">int</span> tx,ty;
<a name="l00289"></a>00289     <span class="keywordtype">long</span> nx,ny;
<a name="l00290"></a>00290     <span class="keywordtype">short</span> nd;
<a name="l00291"></a>00291     <span class="keywordtype">float</span> na;  <span class="comment">//DGT changed from long to float because this has to operate on SSA</span>
<a name="l00292"></a>00292     <span class="keywordtype">int</span> *outletsX, *outletsY;
<a name="l00293"></a>00293     outletsX = <span class="keyword">new</span> <span class="keywordtype">int</span>[nxy];
<a name="l00294"></a>00294     outletsY = <span class="keyword">new</span> <span class="keywordtype">int</span>[nxy];
<a name="l00295"></a>00295     totalAreaProcessed=0;
<a name="l00296"></a>00296     <span class="keywordflow">for</span>( i=0; i&lt;nxy; i++){
<a name="l00297"></a>00297         area.geoToGlobalXY(xnode[i], ynode[i], outletsX[i], outletsY[i]);
<a name="l00298"></a>00298         areaData-&gt;globalToLocal(outletsX[i], outletsY[i], tx, ty);
<a name="l00299"></a>00299         <span class="keywordflow">if</span>(areaData-&gt;isInPartition(tx,ty)){
<a name="l00300"></a>00300             ta=areaData-&gt;getData((<span class="keywordtype">long</span>) tx,(<span class="keywordtype">long</span>) ty,ta);
<a name="l00301"></a>00301         <span class="comment">//only add terminal outlet areas</span>
<a name="l00302"></a>00302         <span class="comment">// check: is terminal outlet iff downstream neighbor has area&lt;=0</span>
<a name="l00303"></a>00303             nd = dirData-&gt;getData((<span class="keywordtype">long</span>) tx,(<span class="keywordtype">long</span>) ty,nd);
<a name="l00304"></a>00304             <span class="comment">//printf(&quot;Outlet direction: %d\n&quot;,nd);  //  DGT Concern that this may be no data</span>
<a name="l00305"></a>00305             nx = tx+d1[nd];
<a name="l00306"></a>00306             ny = ty+d2[nd];
<a name="l00307"></a>00307             <span class="keywordflow">if</span>(ssaData-&gt;isNodata(nx,ny)  || (ssaData-&gt;getData(nx,ny,na)&lt;=0))
<a name="l00308"></a>00308             <span class="comment">//na=ssaData-&gt;getData((long)nx,(long) ny,na);   //DGT changed to ssaData from areaData - end of stream determined from ssa</span>
<a name="l00309"></a>00309                 totalAreaProcessed+=ta;
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312     MPI_Allreduce(&amp;totalAreaProcessed,&amp;ta,1,MPI_FLOAT,MPI_SUM,MCW);
<a name="l00313"></a>00313     totalAreaProcessed = ta*areadx*aready;
<a name="l00314"></a>00314     <span class="comment">// if(!rank)cout &lt;&lt; &quot;totalAreaProcessed = &quot; &lt;&lt; totalAreaProcessed &lt;&lt; endl;</span>
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <span class="comment">// *** fareada no longer needed, so it&#39;s memory can be free&#39;d up</span>
<a name="l00317"></a>00317     <span class="keyword">delete</span> areaData;
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     <span class="comment">// *** instantiate felevg grid partition from elevfile</span>
<a name="l00320"></a>00320     tiffIO elev(elevfile, FLOAT_TYPE);
<a name="l00321"></a>00321     <span class="keywordtype">long</span> elevTotalX = elev.getTotalX();
<a name="l00322"></a>00322     <span class="keywordtype">long</span> elevTotalY = elev.getTotalY();
<a name="l00323"></a>00323     <span class="keywordtype">double</span> elevdx = elev.getdx();
<a name="l00324"></a>00324     <span class="keywordtype">double</span> elevdy = elev.getdy();
<a name="l00325"></a>00325     <span class="comment">//Create partition and read data</span>
<a name="l00326"></a>00326     tdpartition *elevData;
<a name="l00327"></a>00327     elevData = CreateNewPartition(elev.getDatatype(), elevTotalX, elevTotalY, elevdx, elevdy, elev.getNodata());
<a name="l00328"></a>00328     <span class="keywordtype">int</span> elevnx = elevData-&gt;getnx();
<a name="l00329"></a>00329     <span class="keywordtype">int</span> elevny = elevData-&gt;getny();
<a name="l00330"></a>00330     <span class="keywordtype">int</span> elevxstart, elevystart;  
<a name="l00331"></a>00331     elevData-&gt;localToGlobal(0, 0, elevxstart, elevystart);  
<a name="l00332"></a>00332     elev.read((<span class="keywordtype">long</span>)elevxstart, (<span class="keywordtype">long</span>)elevystart, (<span class="keywordtype">long</span>)elevny, (<span class="keywordtype">long</span>)elevnx, elevData-&gt;getGridPointer());
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="comment">// compare to ssa size</span>
<a name="l00336"></a>00336     <span class="keywordflow">if</span>(!elev.compareTiff(ssa)){
<a name="l00337"></a>00337         printf(<span class="stringliteral">&quot;elev and ssa files not the same size. Exiting \n&quot;</span>);
<a name="l00338"></a>00338         MPI_Abort(MCW,5);
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341     <span class="comment">//  Make ssaData, dirData and elevData available to neighboring partitions once here at beginning as these are not changes</span>
<a name="l00342"></a>00342     ssaData-&gt;share();
<a name="l00343"></a>00343     dirData-&gt;share();
<a name="l00344"></a>00344     elevData-&gt;share();
<a name="l00345"></a>00345 
<a name="l00346"></a>00346     <span class="keywordtype">double</span> readt = MPI_Wtime();
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="comment">// num thresholds must be greater than 1</span>
<a name="l00349"></a>00349     <span class="keywordtype">float</span> thresh;
<a name="l00350"></a>00350     <span class="keywordflow">if</span>(nthresh&lt;2){
<a name="l00351"></a>00351         printf(<span class="stringliteral">&quot;Number of thresholds must be greater than 1. \n&quot;</span>);
<a name="l00352"></a>00352         MPI_Abort(MCW,7);
<a name="l00353"></a>00353     }
<a name="l00354"></a>00354     <span class="comment">// *** loop over all thresholds</span>
<a name="l00355"></a>00355     <span class="keywordtype">int</span> th;
<a name="l00356"></a>00356     FILE *fp;
<a name="l00357"></a>00357     <span class="comment">//for(thresh=threshmin;thresh&lt;=threshmax;thresh+=((threshmax-threshmin)/(float) (nthresh-1))){</span>
<a name="l00358"></a>00358     <span class="keywordflow">for</span>(th=0;th&lt;nthresh;++th){
<a name="l00359"></a>00359         <span class="keywordflow">if</span>(steptype==0){
<a name="l00360"></a>00360             <span class="keywordtype">float</span> r = exp((log(threshmax) - log(threshmin)) / (nthresh - 1));
<a name="l00361"></a>00361             thresh = threshmin*pow(r,th);
<a name="l00362"></a>00362         }<span class="keywordflow">else</span>{
<a name="l00363"></a>00363                     <span class="keywordtype">float</span> delta = (threshmax - threshmin) / (nthresh - 1);
<a name="l00364"></a>00364             thresh = threshmin + th * delta;
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         <span class="comment">// *** instantiate arrays to hold results</span>
<a name="l00368"></a>00368         queue &lt;node&gt; que;
<a name="l00369"></a>00369         node t;
<a name="l00370"></a>00370         <span class="comment">//Create partition for numcontributers</span>
<a name="l00371"></a>00371         tdpartition *contribs;
<a name="l00372"></a>00372         tdpartition *orderOut;
<a name="l00373"></a>00373         <span class="comment">//tdpartition *length;</span>
<a name="l00374"></a>00374         tdpartition *elevOut;
<a name="l00375"></a>00375         contribs = CreateNewPartition(SHORT_TYPE, ssaTotalX, ssaTotalY, ssadx, ssady, MISSINGSHORT);
<a name="l00376"></a>00376         <span class="comment">//Create partitions for orderOut,length,elevOut</span>
<a name="l00377"></a>00377         orderOut = CreateNewPartition(SHORT_TYPE, ssaTotalX, ssaTotalY, ssadx, ssady, MISSINGSHORT);
<a name="l00378"></a>00378         <span class="comment">//length = CreateNewPartition(FLOAT_TYPE, ssaTotalX, ssaTotalY, ssadx, ssady, MISSINGFLOAT);</span>
<a name="l00379"></a>00379         <span class="comment">//  Dont need length partition - just accumulate in each partition</span>
<a name="l00380"></a>00380         <span class="keywordtype">double</span> length=0.0;  <span class="comment">// Double so as not to lose little bits when the number is big due to rounding</span>
<a name="l00381"></a>00381         elevOut = CreateNewPartition(FLOAT_TYPE, ssaTotalX, ssaTotalY, ssadx, ssady, MISSINGFLOAT);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         s1=0.0;
<a name="l00384"></a>00384         s2=0.0;
<a name="l00385"></a>00385         s1sq=0.0;
<a name="l00386"></a>00386         s2sq=0.0;
<a name="l00387"></a>00387         n1=0;
<a name="l00388"></a>00388         n2=0;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="comment">// find the number of equal/above-threshold contributers for each cell</span>
<a name="l00391"></a>00391         <span class="keywordtype">long</span> i,j,m;
<a name="l00392"></a>00392         <span class="keywordtype">short</span> d;    
<a name="l00393"></a>00393         <span class="keywordtype">float</span> s;    <span class="comment">//DGT changed from short to float.  ssa is float</span>
<a name="l00394"></a>00394         <span class="keywordtype">long</span> nx = ssanx;
<a name="l00395"></a>00395         <span class="keywordtype">long</span> ny = ssany;
<a name="l00396"></a>00396         <span class="keywordtype">short</span> k=0;
<a name="l00397"></a>00397         <span class="keywordtype">long</span> nexti,nextj;
<a name="l00398"></a>00398         <span class="keywordtype">float</span> e;
<a name="l00399"></a>00399         <span class="comment">// share borders</span>
<a name="l00400"></a>00400         contribs-&gt;clearBorders();   <span class="comment">//  DGT changed from share</span>
<a name="l00401"></a>00401         <span class="keywordflow">for</span>(j=0;j&lt;=ny-1;++j){
<a name="l00402"></a>00402             <span class="keywordflow">for</span>(i=0;i&lt;nx;++i){
<a name="l00403"></a>00403                 <span class="comment">// each cells looks all around and counts the arrows pointing to it</span>
<a name="l00404"></a>00404                 k=0;
<a name="l00405"></a>00405                 <span class="keywordflow">for</span>(m=1;m&lt;=8;++m){
<a name="l00406"></a>00406                     nexti=i+d1[m];
<a name="l00407"></a>00407                     nextj=j+d2[m];
<a name="l00408"></a>00408                     <span class="keywordflow">if</span>(pointsToMe(i,j,nexti,nextj,dirData) &amp;&amp; ssaData-&gt;getData(nexti,nextj,s)&gt;=thresh)k++;
<a name="l00409"></a>00409                 }
<a name="l00410"></a>00410                 <span class="comment">//  Only work with cells on current stream mask</span>
<a name="l00411"></a>00411                 <span class="keywordflow">if</span>(!ssaData-&gt;isNodata(i,j) &amp;&amp; ssaData-&gt;getData(i,j,tempFloat)&gt;=thresh)
<a name="l00412"></a>00412                     contribs-&gt;setData(i,j,k);
<a name="l00413"></a>00413                 <span class="comment">// while we are at it, init data for each cell</span>
<a name="l00414"></a>00414                 <span class="comment">// init streamOrder for each cell to -1</span>
<a name="l00415"></a>00415                 <span class="comment">// DGT does not like this initialization here - they are initialized to no data upon creation</span>
<a name="l00416"></a>00416                 <span class="comment">//  and should be assigned values when they are processed</span>
<a name="l00417"></a>00417                 <span class="comment">//orderOut-&gt;setData(i,j,(short)-1);</span>
<a name="l00418"></a>00418                 <span class="comment">//length-&gt;setData(i,j,(float)0.0);</span>
<a name="l00419"></a>00419                 <span class="comment">//elevOut-&gt;setData(i,j,(float)0.0);</span>
<a name="l00420"></a>00420             }
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         <span class="comment">// put the ones with no contributers onto the que for processing.</span>
<a name="l00424"></a>00424         <span class="keywordflow">for</span>(j=0;j&lt;ny;++j){
<a name="l00425"></a>00425             <span class="keywordflow">for</span>(i=0;i&lt;nx;++i){
<a name="l00426"></a>00426                 <span class="keywordflow">if</span>(!contribs-&gt;getData(i,j,k) &amp;&amp; ssaData-&gt;getData(i,j,s)&gt;=thresh){
<a name="l00427"></a>00427                     t.x=i;
<a name="l00428"></a>00428                     t.y=j;
<a name="l00429"></a>00429                     que.push(t);
<a name="l00430"></a>00430                 }
<a name="l00431"></a>00431                 <span class="comment">// each initial cell gets streamOrder=1</span>
<a name="l00432"></a>00432                 <span class="comment">//  DGT commented out below - will be handled during processing</span>
<a name="l00433"></a>00433                 <span class="comment">//orderOut-&gt;setData(i,j,(short)1) ;</span>
<a name="l00434"></a>00434                 <span class="comment">//elevOut-&gt;setData(i,j,elevData-&gt;getData(i,j,e)) ;</span>
<a name="l00435"></a>00435             }
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         <span class="comment">// each process empties its que, then shares border info, and repeats till everyone is done</span>
<a name="l00439"></a>00439     <span class="comment">//  int globalwork=1; //int not bool for MPI_reduce</span>
<a name="l00440"></a>00440     <span class="comment">//  int localwork=1; //int not bool for MPI_reduce</span>
<a name="l00441"></a>00441         <span class="comment">//  DGT replaced with finished logic from other functions</span>
<a name="l00442"></a>00442         finished=<span class="keyword">false</span>;
<a name="l00443"></a>00443         <span class="keywordflow">while</span>(!finished){
<a name="l00444"></a>00444             <span class="comment">//globalwork=0;</span>
<a name="l00445"></a>00445             <span class="comment">//contribs-&gt;clearBorders();</span>
<a name="l00446"></a>00446             <span class="keywordflow">while</span>(!que.empty()){
<a name="l00447"></a>00447                 t=que.front();
<a name="l00448"></a>00448                 que.pop();
<a name="l00449"></a>00449                 d=dirData-&gt;getData((<span class="keywordtype">long</span>)t.x,(<span class="keywordtype">long</span>)t.y,d);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451                 <span class="comment">// begin cell processing</span>
<a name="l00452"></a>00452                 <span class="keywordtype">long</span> i,j,pi,pj,pd,k;
<a name="l00453"></a>00453                 <span class="keywordtype">short</span> o;
<a name="l00454"></a>00454                 <span class="keywordtype">float</span> e;
<a name="l00455"></a>00455                 i=t.x;
<a name="l00456"></a>00456                 j=t.y;
<a name="l00457"></a>00457 <span class="comment">//              if(i==228 &amp;&amp; j==0 &amp;&amp; rank==1)</span>
<a name="l00458"></a>00458 <span class="comment">//                  i=i;</span>
<a name="l00459"></a>00459                 <span class="keywordtype">short</span> nOrder[8];  <span class="comment">// neighborOrders</span>
<a name="l00460"></a>00460                 <span class="keywordtype">bool</span> junction; <span class="comment">// junction set to true/false in newOrder</span>
<a name="l00461"></a>00461 
<a name="l00462"></a>00462                 <span class="comment">//put the order of all the neighboring cells into an array, and save the i,j, and elev from contributor.</span>
<a name="l00463"></a>00463                 <span class="comment">//pi,pj, and pd are useful only if there is no junction, where there is necessarily one and only</span>
<a name="l00464"></a>00464                                 <span class="comment">//one contributor.</span>
<a name="l00465"></a>00465                 <span class="comment">// TODO:  check against dropanrecursive function</span>
<a name="l00466"></a>00466                 <span class="keywordflow">for</span>(k=0;k&lt;8;++k)nOrder[k]=0;
<a name="l00467"></a>00467                 <span class="comment">//float l=0.0;</span>
<a name="l00468"></a>00468                 <span class="comment">//length-&gt;setData(i,j,l);  // Initialize length to 0</span>
<a name="l00469"></a>00469                 <span class="keywordflow">for</span>(m=1;m&lt;=8;++m){
<a name="l00470"></a>00470                     nexti=i+d1[m];
<a name="l00471"></a>00471                     nextj=j+d2[m];
<a name="l00472"></a>00472                     <span class="keywordflow">if</span>(pointsToMe(i,j,nexti,nextj,dirData) &amp;&amp; !orderOut-&gt;isNodata(nexti,nextj)){
<a name="l00473"></a>00473                         nOrder[m-1]=orderOut-&gt;getData(nexti,nextj,o);
<a name="l00474"></a>00474                         <span class="comment">//  Accumulate length</span>
<a name="l00475"></a>00475                         pd=m;  <span class="comment">//DGT changed from d to m to record direction of neighbor</span>
<a name="l00476"></a>00476                         pi=nexti;
<a name="l00477"></a>00477                         pj=nextj;
<a name="l00478"></a>00478                         <span class="keywordflow">if</span>(pd==1||pd==5)length=length+ssadx;
<a name="l00479"></a>00479                         <span class="keywordflow">if</span>(pd==3||pd==7)length=length+ssady;
<a name="l00480"></a>00480                         <span class="keywordflow">if</span>(pd%2==0)length=length+ssadiag;
<a name="l00481"></a>00481                     }
<a name="l00482"></a>00482                 }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484                 <span class="comment">// Determine the order of this cell</span>
<a name="l00485"></a>00485                 <span class="keywordtype">short</span> oOut;
<a name="l00486"></a>00486                 <span class="keywordtype">bool</span> source;
<a name="l00487"></a>00487                 oOut = newOrder(nOrder,junction,source);
<a name="l00488"></a>00488                 orderOut-&gt;setData(i,j,oOut);
<a name="l00489"></a>00489                 <span class="keywordflow">if</span>(source){
<a name="l00490"></a>00490                     elevOut-&gt;setData(i,j,elevData-&gt;getData(i,j,e));
<a name="l00491"></a>00491                     <span class="comment">//printf(&quot;Source(rank:th:i:j), %d, %d, %d, %d\n&quot;,rank,th,i,j);</span>
<a name="l00492"></a>00492                     <span class="comment">//fflush(stdout);</span>
<a name="l00493"></a>00493                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!junction){
<a name="l00494"></a>00494                     <span class="comment">// if not a junction, transfer elevOut</span>
<a name="l00495"></a>00495                     elevOut-&gt;setData(i,j,elevOut-&gt;getData(pi,pj,e));
<a name="l00496"></a>00496                 }<span class="keywordflow">else</span>{
<a name="l00497"></a>00497                     <span class="comment">// if it is a junction, update global values</span>
<a name="l00498"></a>00498                     <span class="comment">//  oOut = orderOut-&gt;getData(i,j,oOut);  // DGT redundant - was just set above</span>
<a name="l00499"></a>00499                     <span class="keywordtype">bool</span> newstream=<span class="keyword">true</span>;  <span class="comment">// Flag to indicate whether the junction results in a new Strahler stream</span>
<a name="l00500"></a>00500                     <span class="keywordflow">for</span>(k=1;k&lt;=8;++k){
<a name="l00501"></a>00501                         <span class="comment">//  d=dirData-&gt;getData(i+d1[k],j+d2[k],d);  //DGT redundant and overwrites value of d that needed to be saved for below</span>
<a name="l00502"></a>00502                         updateAtJunction(oOut,i,i+d1[k],j,j+d2[k],nx,ny,dirData,
<a name="l00503"></a>00503                                          orderOut,elevOut,elevData,newstream,s1,s1sq,s2,s2sq,n1,n2);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505                     }
<a name="l00506"></a>00506                     <span class="keywordflow">if</span>(newstream)  <span class="comment">// Here all paths terminated at the junction so this is a new stream</span>
<a name="l00507"></a>00507                     {
<a name="l00508"></a>00508                         elevOut-&gt;setData(i,j,elevData-&gt;getData(i,j,e));
<a name="l00509"></a>00509                     }
<a name="l00510"></a>00510                 }
<a name="l00511"></a>00511                 <span class="comment">// end cell processing</span>
<a name="l00512"></a>00512 <span class="comment">//              if((i==227 &amp;&amp; j==127) || (i==228 &amp;&amp; j==127))</span>
<a name="l00513"></a>00513 <span class="comment">//                  i=i;</span>
<a name="l00514"></a>00514 
<a name="l00515"></a>00515                 <span class="keywordtype">short</span> c;
<a name="l00516"></a>00516                 <span class="keywordtype">long</span> nextx,nexty;
<a name="l00517"></a>00517                 nextx=t.x+d1[d];
<a name="l00518"></a>00518                 nexty=t.y+d2[d];
<a name="l00519"></a>00519                 contribs-&gt;addToData(nextx,nexty,(<span class="keywordtype">short</span>)-1);
<a name="l00520"></a>00520                 <span class="comment">//Check if neighbor needs to be added to que</span>
<a name="l00521"></a>00521                 <span class="keywordflow">if</span>(elevOut-&gt;isInPartition(nextx,nexty) &amp;&amp; contribs-&gt;getData(nextx, nexty, tempShort) == 0 ){
<a name="l00522"></a>00522                     t.x=nextx;
<a name="l00523"></a>00523                     t.y=nexty;
<a name="l00524"></a>00524                     que.push(t);
<a name="l00525"></a>00525                 }
<a name="l00526"></a>00526             }
<a name="l00527"></a>00527             <span class="comment">//Pass information</span>
<a name="l00528"></a>00528 
<a name="l00529"></a>00529             <span class="comment">//any touched border cells have negative numbers in them.</span>
<a name="l00530"></a>00530             <span class="comment">//push them back to their owners, add the negatives to local</span>
<a name="l00531"></a>00531             <span class="comment">//cells, and put the zero cells on the local que.</span>
<a name="l00532"></a>00532             contribs-&gt;addBorders();
<a name="l00533"></a>00533             
<a name="l00534"></a>00534             <span class="comment">//also push back the data for each border cell</span>
<a name="l00535"></a>00535             <span class="comment">//length-&gt;share();</span>
<a name="l00536"></a>00536             elevOut-&gt;share();
<a name="l00537"></a>00537             orderOut-&gt;share();
<a name="l00538"></a>00538             <span class="comment">//If this created a cell with no contributing neighbors, put it on the queue</span>
<a name="l00539"></a>00539             <span class="keywordflow">for</span>(i=0; i&lt;nx; i++){
<a name="l00540"></a>00540 <span class="comment">//              if(i == 228)</span>
<a name="l00541"></a>00541 <span class="comment">//                  i=i;</span>
<a name="l00542"></a>00542                 <span class="keywordflow">if</span>(contribs-&gt;getData(i, -1, tempShort)!=0 &amp;&amp; contribs-&gt;getData(i, 0, tempShort)==0)
<a name="l00543"></a>00543                 {
<a name="l00544"></a>00544                     t.x = i;
<a name="l00545"></a>00545                     t.y = 0;
<a name="l00546"></a>00546                     que.push(t);
<a name="l00547"></a>00547                 }
<a name="l00548"></a>00548                 <span class="keywordflow">if</span>(contribs-&gt;getData(i, ny, tempShort)!=0 &amp;&amp; contribs-&gt;getData(i, ny-1, tempShort)==0)
<a name="l00549"></a>00549                 {
<a name="l00550"></a>00550                     t.x = i;
<a name="l00551"></a>00551                     t.y = ny-1;
<a name="l00552"></a>00552                     que.push(t); 
<a name="l00553"></a>00553                 }
<a name="l00554"></a>00554             }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556             contribs-&gt;clearBorders();
<a name="l00557"></a>00557         
<a name="l00558"></a>00558             <span class="comment">//Check if done</span>
<a name="l00559"></a>00559             finished = que.empty();
<a name="l00560"></a>00560             finished = orderOut-&gt;ringTerm(finished);
<a name="l00561"></a>00561         }
<a name="l00562"></a>00562     
<a name="l00563"></a>00563         <span class="comment">// *** calculate and write results</span>
<a name="l00564"></a>00564         MPI_Barrier(MCW);
<a name="l00565"></a>00565         <span class="keywordtype">float</span> gs1,gs2,gs1sq,gs2sq;
<a name="l00566"></a>00566         <span class="keywordtype">double</span> glen;
<a name="l00567"></a>00567         <span class="keywordtype">int</span> gn1,gn2;
<a name="l00568"></a>00568         
<a name="l00569"></a>00569         MPI_Reduce(&amp;s1,&amp;gs1,1,MPI_FLOAT,MPI_SUM,0,MCW);
<a name="l00570"></a>00570         MPI_Reduce(&amp;s2,&amp;gs2,1,MPI_FLOAT,MPI_SUM,0,MCW);
<a name="l00571"></a>00571         MPI_Reduce(&amp;s1sq,&amp;gs1sq,1,MPI_FLOAT,MPI_SUM,0,MCW);
<a name="l00572"></a>00572         MPI_Reduce(&amp;s2sq,&amp;gs2sq,1,MPI_FLOAT,MPI_SUM,0,MCW);
<a name="l00573"></a>00573         MPI_Reduce(&amp;n1,&amp;gn1,1,MPI_INT,MPI_SUM,0,MCW);
<a name="l00574"></a>00574         MPI_Reduce(&amp;n2,&amp;gn2,1,MPI_INT,MPI_SUM,0,MCW);
<a name="l00575"></a>00575         MPI_Reduce(&amp;length,&amp;glen,1,MPI_DOUBLE,MPI_SUM,0,MCW);
<a name="l00576"></a>00576         <span class="keywordtype">float</span> drainden=glen/totalAreaProcessed;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         <span class="keywordflow">if</span>(!rank &amp;&amp; th==0){
<a name="l00579"></a>00579             cout &lt;&lt; <span class="stringliteral">&quot;Threshold&quot;</span>;
<a name="l00580"></a>00580             cout &lt;&lt; <span class="stringliteral">&quot; DrainDen&quot;</span>;
<a name="l00581"></a>00581             cout &lt;&lt; <span class="stringliteral">&quot; NoFirstOrd&quot;</span>;
<a name="l00582"></a>00582             cout &lt;&lt; <span class="stringliteral">&quot; NoHighOrd&quot;</span>;
<a name="l00583"></a>00583             cout &lt;&lt; <span class="stringliteral">&quot; MeanDFirstOrd&quot;</span>;
<a name="l00584"></a>00584             cout &lt;&lt; <span class="stringliteral">&quot; MeanDHighOrd&quot;</span>;
<a name="l00585"></a>00585             cout &lt;&lt; <span class="stringliteral">&quot; StdDevFirstOrd&quot;</span>;
<a name="l00586"></a>00586             cout &lt;&lt; <span class="stringliteral">&quot; StdDevHighOrd&quot;</span>;
<a name="l00587"></a>00587             cout &lt;&lt; <span class="stringliteral">&quot; Tval&quot;</span>;
<a name="l00588"></a>00588             cout &lt;&lt; endl;
<a name="l00589"></a>00589     
<a name="l00590"></a>00590             fp = fopen(dropfile,<span class="stringliteral">&quot;w&quot;</span>);
<a name="l00591"></a>00591             fprintf(fp,<span class="stringliteral">&quot;Threshold, DrainDen, NoFirstOrd,NoHighOrd, MeanDFirstOrd, MeanDHighOrd, StdDevFirstOrd, StdDevHighOrd, T\n&quot;</span>);
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         }
<a name="l00594"></a>00594         <span class="keywordflow">if</span>(!rank){
<a name="l00595"></a>00595             cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(6) &lt;&lt; thresh;
<a name="l00596"></a>00596             cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00597"></a>00597             cout &lt;&lt; drainden;
<a name="l00598"></a>00598             cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00599"></a>00599             cout &lt;&lt; gn1;
<a name="l00600"></a>00600             cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00601"></a>00601             cout &lt;&lt; gn2;
<a name="l00602"></a>00602             cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00603"></a>00603             <span class="keywordtype">float</span> md1 = gs1/gn1; 
<a name="l00604"></a>00604             <span class="keywordflow">if</span>(gn1&gt;0)cout &lt;&lt; md1; <span class="keywordflow">else</span> cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span>;
<a name="l00605"></a>00605             cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00606"></a>00606             <span class="keywordtype">float</span> mdh = gs2/gn2; 
<a name="l00607"></a>00607             <span class="keywordflow">if</span>(gn2&gt;0)cout &lt;&lt; mdh; <span class="keywordflow">else</span> cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span>;
<a name="l00608"></a>00608             cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00609"></a>00609             <span class="keywordtype">float</span> sd1 = sqrt((gs1sq-gn1*md1*md1)/(gn1-1)); 
<a name="l00610"></a>00610             <span class="keywordflow">if</span>(gn1 &gt; 1)cout &lt;&lt; sd1;  <span class="keywordflow">else</span> cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span>;
<a name="l00611"></a>00611             cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00612"></a>00612             <span class="keywordtype">float</span> sdh = sqrt((gs2sq-gn2*mdh*mdh)/(gn2-1)); 
<a name="l00613"></a>00613             <span class="keywordflow">if</span>(gn2 &gt; 1) cout &lt;&lt; sdh; <span class="keywordflow">else</span> cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span>;
<a name="l00614"></a>00614             cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00615"></a>00615             <span class="keywordtype">float</span> t = (md1-mdh)/(sqrt(((gn1-1)*sd1*sd1+(gn2-1)*sdh*sdh) / (gn1+gn2-2))*sqrt(1./gn1+1./gn2));
<a name="l00616"></a>00616             <span class="keywordflow">if</span>(gn2 &gt; 1) cout &lt;&lt; t; <span class="keywordflow">else</span> cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span>;
<a name="l00617"></a>00617             cout &lt;&lt; endl;
<a name="l00618"></a>00618             
<a name="l00619"></a>00619             <span class="keywordflow">if</span>(fabs(t) &lt; 2. &amp;&amp; optnotset){ <span class="comment">// Find first occurrence of t value with absolute value less than 2.</span>
<a name="l00620"></a>00620                     <span class="comment">//  This is the optimum</span>
<a name="l00621"></a>00621                 *threshopt=thresh;
<a name="l00622"></a>00622                 optnotset=<span class="keyword">false</span>;
<a name="l00623"></a>00623             }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625                        <span class="comment">//  write results</span>
<a name="l00626"></a>00626             <span class="keywordflow">if</span>(gn1 &gt; 1 &amp;&amp; gn2 &gt; 1)
<a name="l00627"></a>00627             {
<a name="l00628"></a>00628                 fprintf(fp,<span class="stringliteral">&quot;%f, &quot;</span>,thresh);
<a name="l00629"></a>00629                 fprintf(fp,<span class="stringliteral">&quot;%e, &quot;</span>,drainden);
<a name="l00630"></a>00630                 fprintf(fp,<span class="stringliteral">&quot;%d, &quot;</span>,gn1);
<a name="l00631"></a>00631                 fprintf(fp,<span class="stringliteral">&quot;%d, &quot;</span>,gn2);
<a name="l00632"></a>00632                 fprintf(fp,<span class="stringliteral">&quot;%f, &quot;</span>,md1);
<a name="l00633"></a>00633                 fprintf(fp,<span class="stringliteral">&quot;%f, &quot;</span>,mdh);
<a name="l00634"></a>00634                 fprintf(fp,<span class="stringliteral">&quot;%f, &quot;</span>,sd1);
<a name="l00635"></a>00635                 fprintf(fp,<span class="stringliteral">&quot;%f, &quot;</span>,sdh);
<a name="l00636"></a>00636                 fprintf(fp,<span class="stringliteral">&quot;%f\n&quot;</span>,t);
<a name="l00637"></a>00637             }
<a name="l00638"></a>00638         }
<a name="l00639"></a>00639         <span class="comment">//  dgt freeing memory</span>
<a name="l00640"></a>00640         <span class="keyword">delete</span>  contribs;
<a name="l00641"></a>00641         <span class="keyword">delete</span>  orderOut;
<a name="l00642"></a>00642         <span class="keyword">delete</span>  elevOut;
<a name="l00643"></a>00643     }
<a name="l00644"></a>00644     
<a name="l00645"></a>00645     <span class="keywordtype">float</span> topt = *threshopt;
<a name="l00646"></a>00646     MPI_Bcast(&amp;topt,1,MPI_FLOAT,0,MCW);
<a name="l00647"></a>00647     *threshopt = topt;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="keywordflow">if</span>(!rank)
<a name="l00650"></a>00650     {
<a name="l00651"></a>00651         printf(<span class="stringliteral">&quot;%f  Value for optimum that drop analysis selected - see output file for details.\n&quot;</span>, *threshopt);
<a name="l00652"></a>00652         <span class="comment">//cout &lt;&lt; &quot;Optimum Threshold Value: &quot; &lt;&lt; *threshopt &lt;&lt; endl;</span>
<a name="l00653"></a>00653         fprintf(fp,<span class="stringliteral">&quot;Optimum Threshold Value: %f\n&quot;</span>,*threshopt);
<a name="l00654"></a>00654         fclose(fp);
<a name="l00655"></a>00655     }
<a name="l00656"></a>00656     <span class="keywordtype">float</span> computeDropt = MPI_Wtime();
<a name="l00657"></a>00657     <span class="keywordtype">double</span> dataRead, compute, total,temp;
<a name="l00658"></a>00658         dataRead = readt-begint;
<a name="l00659"></a>00659         compute = computeDropt-readt;
<a name="l00660"></a>00660         total = computeDropt - begint;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662         MPI_Allreduce (&amp;dataRead, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00663"></a>00663         dataRead = temp/size;
<a name="l00664"></a>00664         MPI_Allreduce (&amp;compute, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00665"></a>00665         compute = temp/size;
<a name="l00666"></a>00666         MPI_Allreduce (&amp;total, &amp;temp, 1, MPI_DOUBLE, MPI_SUM, MCW);
<a name="l00667"></a>00667         total = temp/size;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669         <span class="keywordflow">if</span>( rank == 0)
<a name="l00670"></a>00670                 printf(<span class="stringliteral">&quot;Processes: %d\nRead time: %f\nCompute time: %f\nTotal time: %f\n&quot;</span>,
<a name="l00671"></a>00671                   size, dataRead, compute,total);
<a name="l00672"></a>00672     
<a name="l00673"></a>00673     <span class="comment">// *** free memory and go home</span>
<a name="l00674"></a>00674     <span class="keyword">delete</span>  ssaData;
<a name="l00675"></a>00675     <span class="keyword">delete</span>  dirData;
<a name="l00676"></a>00676     <span class="keyword">delete</span>  xnode;
<a name="l00677"></a>00677     <span class="keyword">delete</span>  ynode;
<a name="l00678"></a>00678     <span class="keyword">delete</span>  elevData;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680     }MPI_Finalize();
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="keywordflow">return</span> 0;
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 13 2016 06:11:36 for SEIMS-2016 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
